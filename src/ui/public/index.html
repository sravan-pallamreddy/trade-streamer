<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Trade Streamer</title>
    <link rel="icon" type="image/svg+xml" href="/favicon.svg">
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://unpkg.com/lucide@latest/dist/umd/lucide.js"></script>
    <style>
        body {
            font-family: "Inter", "SF Pro Text", "SF Pro Display", -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
            font-feature-settings: "ss01" on, "ss02" on;
        }
        .tag-chip {
            background-color: #F3F4F6;
            color: #4B5563;
            transition: background-color 0.2s ease, color 0.2s ease;
        }
        .tag-chip:hover {
            background-color: #E5E7EB;
        }
        .track-btn {
            transition: background-color 0.2s ease, color 0.2s ease, border-color 0.2s ease;
        }
        .track-btn[data-track-state="tracked"] {
            background-color: #ECFDF5;
            color: #065F46;
            border-color: #A7F3D0;
        }
        .tracked-idea-tile {
            border-left-width: 4px;
            transition: transform 0.2s ease, box-shadow 0.2s ease;
        }
        .tracked-idea-tile:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 10px rgba(15, 23, 42, 0.08);
        }
        .tracked-idea-pill {
            font-size: 0.7rem;
            letter-spacing: 0.08em;
        }
        .tracked-floating-panel {
            position: fixed;
            left: 1.5rem;
            bottom: 1.5rem;
            width: 320px;
            max-height: 70vh;
            overflow-y: auto;
            z-index: 50;
            box-shadow: 0 20px 45px rgba(15, 23, 42, 0.2);
            transition: opacity 0.2s ease, transform 0.2s ease;
        }
        .tracked-floating-panel.hidden {
            display: none;
        }
        .tracked-floating-toggle {
            position: fixed;
            left: 1.5rem;
            bottom: 1.5rem;
            z-index: 40;
            box-shadow: 0 6px 20px rgba(15, 23, 42, 0.2);
        }
        .day-pl-panel {
            width: min(22rem, 90vw);
            z-index: 60;
        }
        .day-pl-panel-scroll {
            scrollbar-width: thin;
        }
        body.day-pl-panel-open {
            padding-right: 22rem;
            transition: padding-right 0.2s ease;
        }
        @media (max-width: 1024px) {
            body.day-pl-panel-open {
                padding-right: 0;
            }
        }
    </style>
</head>
<body class="bg-gray-100 min-h-screen">
    <div class="container mx-auto px-4 py-8">
        <!-- Header -->
        <div class="bg-white rounded-lg shadow-md p-6 mb-6">
            <div class="flex justify-between items-center">
                <div class="flex flex-wrap items-center gap-6 sm:gap-8">
                    <img src="/logo.svg" alt="Trade Streamer" class="h-10 w-auto sm:h-12">
                </div>
                <div class="flex items-start gap-3">
                    <div class="text-right space-y-1">
                        <div>
                            <div id="headerBalance" class="text-2xl font-bold text-green-600">$****</div>
                            <div class="text-sm text-gray-500">Account Balance</div>
                        </div>
                        <div id="headerAvailableCash" class="text-xs font-semibold text-slate-500 uppercase tracking-wide">Available Cash: $****</div>
                        <div id="headerCashWithdraw" class="text-xs font-semibold text-slate-500 uppercase tracking-wide">Cash To Withdraw: $****</div>
                    </div>
                    <button id="toggleSensitiveBtn" class="inline-flex items-center gap-2 text-sm text-gray-500 hover:text-gray-700 border border-gray-200 rounded-lg px-3 py-2 bg-white" type="button">
                        <i id="toggleSensitiveIcon" data-lucide="eye-off" class="w-4 h-4"></i>
                        <span id="toggleSensitiveLabel">Show Details</span>
                    </button>
                </div>
            </div>
            <h1 class="sr-only">Trade Streamer – AI Strategy Playbooks for Day Trading</h1>
        </div>

        <div class="flex justify-end gap-2 mb-4">
            <button id="collapseLeftBtn" type="button" class="inline-flex items-center gap-2 text-xs font-semibold text-slate-600 hover:text-slate-800 border border-slate-200 rounded-lg px-3 py-2 bg-white shadow-sm">
                <i id="collapseLeftIcon" data-lucide="chevron-left" class="w-4 h-4"></i>
                <span id="collapseLeftLabel">Hide Scan Panel</span>
            </button>
            <button id="collapseRightBtn" type="button" class="inline-flex items-center gap-2 text-xs font-semibold text-slate-600 hover:text-slate-800 border border-slate-200 rounded-lg px-3 py-2 bg-white shadow-sm">
                <i id="collapseRightIcon" data-lucide="chevron-right" class="w-4 h-4"></i>
                <span id="collapseRightLabel">Hide Portfolio Rail</span>
            </button>
        </div>

    <div id="layoutGrid" class="xl:grid xl:grid-cols-[320px_minmax(0,1.4fr)_360px] gap-8 items-start">
            <aside id="scanSidebar" class="space-y-6 xl:sticky xl:top-6">
                <div class="bg-white rounded-xl shadow-md border border-slate-100 p-6" id="scanPanel">
                    <div class="flex items-start justify-between gap-3">
                        <div class="flex-1 space-y-3">
                            <div class="flex flex-wrap items-center gap-3">
                                <button id="scanBtn" class="bg-blue-600 hover:bg-blue-700 text-white px-5 py-2.5 rounded-lg font-semibold flex items-center gap-2">
                                    <i data-lucide="search" class="w-5 h-5"></i>
                                    Scan for Trades
                                </button>
                                <span class="text-xs font-semibold uppercase tracking-wide text-emerald-600">Portfolio auto-sync enabled</span>
                            </div>
                            <div id="scanStatus" class="text-sm text-slate-600 flex items-center gap-2 rounded-lg border border-slate-200 bg-slate-50 px-3 py-2">
                                <i data-lucide="clock" class="w-4 h-4"></i>
                                Waiting for first scan
                            </div>
                        </div>
                        <button id="toggleScanPanelBtn" type="button" class="inline-flex items-center gap-1 text-xs font-semibold text-slate-500 hover:text-slate-700 border border-slate-200 rounded-lg px-2.5 py-2 bg-white" aria-expanded="true">
                            <i id="toggleScanPanelIcon" data-lucide="chevron-up" class="w-4 h-4"></i>
                            <span id="toggleScanPanelLabel">Collapse</span>
                        </button>
                    </div>
                    <div id="scanPanelBody" class="mt-5 space-y-5">
                        <div class="space-y-2">
                            <div class="flex items-center justify-between">
                                <label for="symbolsInput" class="text-sm font-semibold text-slate-700">Symbols to scan</label>
                                <span class="text-[11px] uppercase tracking-wide text-slate-400">Max 24</span>
                            </div>
                            <div class="flex flex-col gap-2">
                                <input id="symbolsInput" type="text" class="border border-slate-300 rounded-lg px-3 py-2 text-sm focus:outline-none focus:ring-2 focus:ring-blue-500" placeholder="SPY, QQQ, AAPL, ...">
                                <button id="saveSymbolsBtn" class="bg-slate-800 hover:bg-slate-900 text-white px-4 py-2 rounded-lg font-semibold flex items-center gap-2 justify-center">
                                    <i data-lucide="save" class="w-4 h-4"></i>
                                    Save Scan Settings
                                </button>
                            </div>
                            <div id="symbolsStatus" class="text-xs text-slate-500 flex items-center gap-2">
                                <i data-lucide="info" class="w-4 h-4"></i>
                                Loading scan settings...
                            </div>
                        </div>
                        <div class="space-y-2">
                            <label for="strategySelect" class="text-sm font-semibold text-slate-700">Strategy focus</label>
                            <select id="strategySelect" class="w-full border border-slate-300 rounded-lg px-3 py-2 text-sm focus:outline-none focus:ring-2 focus:ring-blue-500">
                                <option value="day_trade">Day Trade (intraday)</option>
                                <option value="swing_trade">Swing Trade (multi-day)</option>
                            </select>
                            <div id="strategyStatus" class="text-xs text-slate-500 flex items-center gap-2">
                                <i data-lucide="info" class="w-4 h-4"></i>
                                Loading strategy preference...
                            </div>
                        </div>
                        <div class="border-t border-slate-200 pt-4 space-y-3">
                            <div class="text-xs font-semibold uppercase tracking-wide text-slate-500">Quick Insights</div>
                            <ul id="scanInsights" class="space-y-2 text-sm text-slate-600">
                                <li class="flex items-start gap-2">
                                    <i data-lucide="activity" class="w-4 h-4 text-blue-500 mt-0.5"></i>
                                    <span>Awaiting initial scan...</span>
                                </li>
                            </ul>
                        </div>
                    </div>
                </div>
            </aside>

            <main class="space-y-6">
                <div id="recommendationSummary" class="grid grid-cols-1 sm:grid-cols-2 xl:grid-cols-4 gap-4"></div>
                <div id="recommendations" class="grid grid-cols-1 lg:grid-cols-2 2xl:grid-cols-3 gap-6 auto-rows-fr">
                    <!-- Recommendations will be inserted here -->
                </div>
            </main>

            <aside id="portfolioRail" class="hidden xl:flex xl:flex-col gap-4">
                <div id="portfolioSummaryCard" class="bg-white rounded-xl shadow-md border border-slate-100 p-5 space-y-4">
                    <div class="flex items-start justify-between gap-3">
                        <div>
                            <h2 class="text-lg font-semibold text-slate-800 flex items-center gap-2">
                                <i data-lucide="wallet" class="w-4 h-4 text-emerald-500"></i>
                                Options Portfolio
                            </h2>
                            <span id="portfolioStatus" class="text-xs text-slate-500"></span>
                        </div>
                        <button id="refreshPortfolioBtn" type="button" class="inline-flex items-center gap-2 text-xs font-semibold text-slate-600 hover:text-slate-800 border border-slate-200 rounded-lg px-3 py-2 bg-white">
                            <i data-lucide="refresh-cw" class="w-3 h-3"></i>
                            <span>Refresh</span>
                        </button>
                    </div>
                    <div id="accountSummary" class="grid grid-cols-2 gap-3 text-sm"></div>
                </div>
                <div class="bg-white rounded-xl shadow-md border border-slate-100 p-4 flex-1 overflow-y-auto max-h-[70vh]">
                    <div class="flex items-center justify-between mb-3">
                        <h3 class="text-sm font-semibold text-slate-700 flex items-center gap-2">
                            <i data-lucide="zap" class="w-4 h-4 text-purple-500"></i>
                            Active Options
                        </h3>
                        <span class="text-[11px] uppercase tracking-wide text-slate-400" id="portfolioOptionsMeta"></span>
                    </div>
                    <div id="portfolioOptionsList" class="space-y-3"></div>
                    <div id="portfolioEmptyState" class="text-center text-sm text-slate-500 bg-slate-50 border border-dashed border-slate-200 rounded-lg p-5 hidden">
                        <i data-lucide="archive" class="w-6 h-6 text-slate-300 mx-auto mb-2"></i>
                        <div>No options positions yet.</div>
                        <div class="text-xs text-slate-400">Connect your account or refresh to see updates.</div>
                    </div>
                </div>
            </aside>
        </div>
    </div>

    <div id="trackedIdeasFloating" class="tracked-floating-panel bg-white rounded-xl border border-slate-100 p-5 space-y-4">
        <div class="flex items-start justify-between gap-3">
            <div>
                <h2 class="text-sm font-semibold text-slate-800 flex items-center gap-2">
                    <i data-lucide="bookmark" class="w-4 h-4 text-amber-500"></i>
                    Tracked Ideas
                </h2>
                <p class="text-xs text-slate-500">Pin options and monitor buy / wait / ignore cues.</p>
            </div>
            <div class="flex items-center gap-2">
                <button id="collapseTrackedIdeasBtn" type="button" class="inline-flex items-center justify-center text-xs font-semibold text-slate-500 hover:text-slate-700 border border-slate-200 rounded-lg px-2 py-1 bg-white" aria-label="Collapse tracked ideas">
                    <i data-lucide="chevron-down" class="w-4 h-4"></i>
                </button>
                <button id="clearTrackedIdeasBtn" type="button" class="text-[11px] font-semibold uppercase tracking-wide text-slate-400 hover:text-slate-600 transition" aria-label="Clear tracked ideas" disabled>
                    Clear
                </button>
            </div>
        </div>
        <div id="trackedIdeasEmpty" class="text-sm text-slate-500 bg-slate-50 border border-dashed border-slate-200 rounded-lg p-4 flex gap-2">
            <i data-lucide="bookmark-plus" class="w-4 h-4 text-slate-400"></i>
            <span>Tap "Track Idea" on any card to pin it here.</span>
        </div>
        <div id="trackedIdeasList" class="space-y-3"></div>
        <div id="trackedIdeasStatus" class="text-[11px] uppercase tracking-wide text-slate-400"></div>
    </div>

    <button id="trackedIdeasToggleBtn" type="button" class="tracked-floating-toggle hidden bg-white text-slate-700 text-xs font-semibold uppercase tracking-wide rounded-full px-4 py-2">
        Show Tracked Ideas
    </button>

    <div id="dayPlPanel" class="day-pl-panel hidden fixed top-0 right-0 h-full w-80 bg-white border-l border-slate-200 shadow-2xl flex flex-col translate-x-0 transition-transform duration-300 ease-out">
        <div class="flex items-center justify-between px-5 py-4 border-b border-slate-100">
            <div>
                <div class="text-xs uppercase tracking-wide text-slate-500 flex items-center gap-1">
                    <i data-lucide="activity" class="w-3 h-3 text-emerald-500"></i>
                    Day P/L
                </div>
                <div id="dayPlTotal" class="text-3xl font-semibold text-emerald-600 mt-1">$0.00</div>
                <div id="dayPlSummaryMeta" class="text-xs text-slate-500 mt-1">Awaiting portfolio sync...</div>
            </div>
            <button id="dayPlToggleHandle" type="button" class="inline-flex items-center gap-1 text-xs font-semibold text-slate-500 hover:text-slate-800 border border-slate-200 rounded-full px-3 py-1.5">
                <i data-lucide="chevron-right" class="w-4 h-4"></i>
                <span>Hide</span>
            </button>
        </div>
        <div id="dayPlUpdatedAt" class="px-5 py-2 border-b border-slate-100 text-xs text-slate-500">Not updated yet</div>
        <div id="dayPlPositions" class="day-pl-panel-scroll flex-1 overflow-y-auto">
            <div class="p-5 text-sm text-slate-500">Day P/L will appear after the portfolio syncs.</div>
        </div>
    </div>
    <button id="dayPlRevealBtn" type="button" class="hidden fixed top-1/2 right-0 -translate-y-1/2 bg-slate-900 text-white text-xs font-semibold tracking-wide px-3 py-2 rounded-l-xl shadow-lg z-50">
        <span>Day P/L</span>
    </button>

    <script>
        // Initialize Lucide icons
        lucide.createIcons();

    const scanSidebar = document.getElementById('scanSidebar');
    const scanBtn = document.getElementById('scanBtn');
    const scanStatus = document.getElementById('scanStatus');
    const recommendations = document.getElementById('recommendations');
    const portfolioRail = document.getElementById('portfolioRail');
    const accountSummary = document.getElementById('accountSummary');
    const portfolioOptionsList = document.getElementById('portfolioOptionsList');
    const portfolioEmptyState = document.getElementById('portfolioEmptyState');
    const portfolioOptionsMeta = document.getElementById('portfolioOptionsMeta');
    const layoutGrid = document.getElementById('layoutGrid');
    const collapseLeftBtn = document.getElementById('collapseLeftBtn');
    const collapseLeftIcon = document.getElementById('collapseLeftIcon');
    const collapseLeftLabel = document.getElementById('collapseLeftLabel');
    const collapseRightBtn = document.getElementById('collapseRightBtn');
    const collapseRightIcon = document.getElementById('collapseRightIcon');
    const collapseRightLabel = document.getElementById('collapseRightLabel');
    const toggleScanPanelBtn = document.getElementById('toggleScanPanelBtn');
    const toggleScanPanelIcon = document.getElementById('toggleScanPanelIcon');
    const toggleScanPanelLabel = document.getElementById('toggleScanPanelLabel');
    const scanPanelBody = document.getElementById('scanPanelBody');
        const headerBalance = document.getElementById('headerBalance');
        const headerAvailableCash = document.getElementById('headerAvailableCash');
        const headerCashWithdraw = document.getElementById('headerCashWithdraw');
        const toggleSensitiveBtn = document.getElementById('toggleSensitiveBtn');
        const refreshPortfolioBtn = document.getElementById('refreshPortfolioBtn');
        const portfolioStatus = document.getElementById('portfolioStatus');
        const symbolsInput = document.getElementById('symbolsInput');
        const saveSymbolsBtn = document.getElementById('saveSymbolsBtn');
    const symbolsStatus = document.getElementById('symbolsStatus');
    const strategySelect = document.getElementById('strategySelect');
    const strategyStatus = document.getElementById('strategyStatus');
    const trackedIdeasPanel = document.getElementById('trackedIdeasFloating');
    const trackedIdeasList = document.getElementById('trackedIdeasList');
    const trackedIdeasEmpty = document.getElementById('trackedIdeasEmpty');
    const trackedIdeasStatus = document.getElementById('trackedIdeasStatus');
    const clearTrackedIdeasBtn = document.getElementById('clearTrackedIdeasBtn');
    const collapseTrackedIdeasBtn = document.getElementById('collapseTrackedIdeasBtn');
    const trackedIdeasToggleBtn = document.getElementById('trackedIdeasToggleBtn');
    const recommendationSummary = document.getElementById('recommendationSummary');
    const scanInsights = document.getElementById('scanInsights');
    const dayPlPanel = document.getElementById('dayPlPanel');
    const dayPlToggleHandle = document.getElementById('dayPlToggleHandle');
    const dayPlRevealBtn = document.getElementById('dayPlRevealBtn');
    const dayPlTotal = document.getElementById('dayPlTotal');
    const dayPlSummaryMeta = document.getElementById('dayPlSummaryMeta');
    const dayPlUpdatedAt = document.getElementById('dayPlUpdatedAt');
    const dayPlPositions = document.getElementById('dayPlPositions');

        const POLL_INTERVAL_MS = 15000;
        const PORTFOLIO_REFRESH_INTERVAL_MS = 60000;
        let recommendationsTimer = null;
        let portfolioRefreshTimer = null;
        let currentSymbolList = [];
        let currentStrategy = 'day_trade';
    let lastRecommendationStats = null;
    let lastScanMetaPayload = null;
    let scanPanelCollapsed = false;
    let leftSidebarCollapsed = false;
    let rightSidebarCollapsed = false;
        let revealSensitive = false;
        let lastBalancePayload = null;
        let lastPortfolioPayload = null;
        let lastPortfolioBalance = null;
        let lastPortfolioRefreshAt = null;
        let portfolioAutoInitStarted = false;
    let dayPlPanelOpen = true;
    let lastDayPlSnapshot = null;
    let lastDayOrdersPayload = null;
    const TRACKED_STORAGE_KEY = 'trade_streamer_tracked_ideas_v1';
    const TRACKED_IDEA_LIMIT = 8;
    let trackedIdeas = [];
    let trackedPanelCollapsed = false;
    const autoExitDefaults = {
        enabled: false,
        takeProfitPct: 40,
        stopLossPct: -35,
        scalePct: 0.5,
        minContracts: 1,
        cooldownMs: 300000,
    };
    const autoExitState = { ...autoExitDefaults };
    const autoExitCooldowns = new Map();
    const autoExitPending = new Set();
    initDayPlPanel();

        // Update header balance display
        function updateHeaderBalance(balanceData) {
            lastBalancePayload = balanceData || null;
            renderHeaderBalance();
        }

        function escapeHtml(text) {
            if (text == null) return '';
            return text.toString().replace(/[&<>"']/g, (char) => {
                const map = { '&': '&amp;', '<': '&lt;', '>': '&gt;', '"': '&quot;', "'": '&#39;' };
                return map[char] || char;
            });
        }

        function normalizeSymbolInput(value) {
            if (!value) return [];
            const parts = Array.isArray(value) ? value : value.split(/[,\s]+/);
            const seen = new Set();
            const out = [];
            for (const raw of parts) {
                if (!raw) continue;
                const symbol = raw.toString().trim().toUpperCase();
                if (!symbol) continue;
                if (!/^[A-Z0-9.\-]{1,12}$/.test(symbol)) continue;
                if (seen.has(symbol)) continue;
                seen.add(symbol);
                out.push(symbol);
            }
            return out;
        }

        function arraysShallowEqual(a, b) {
            if (!Array.isArray(a) || !Array.isArray(b)) return false;
            if (a.length !== b.length) return false;
            for (let i = 0; i < a.length; i++) {
                if (a[i] !== b[i]) return false;
            }
            return true;
        }

        function setTrackedPanelCollapsed(collapsed) {
            trackedPanelCollapsed = !!collapsed;
            if (!trackedIdeasPanel || !trackedIdeasToggleBtn) return;
            if (trackedPanelCollapsed) {
                trackedIdeasPanel.classList.add('hidden');
                trackedIdeasToggleBtn.classList.remove('hidden');
            } else {
                trackedIdeasPanel.classList.remove('hidden');
                trackedIdeasToggleBtn.classList.add('hidden');
            }
            if (collapseTrackedIdeasBtn) {
                const icon = collapseTrackedIdeasBtn.querySelector('i');
                if (icon) {
                    icon.setAttribute('data-lucide', trackedPanelCollapsed ? 'chevron-up' : 'chevron-down');
                }
            }
            lucide.createIcons();
        }

        function normalizeDecision(value) {
            const token = (value || '').toString().toLowerCase();
            if (!token) return 'unknown';
            if (token.includes('approve') || token.includes('strong') || token === 'buy') return 'approve';
            if (token.includes('caution') || token.includes('hold') || token === 'watch') return 'caution';
            if (token.includes('reject') || token.includes('avoid') || token.includes('sell')) return 'reject';
            return 'unknown';
        }

        function buildIdeaId({ symbol, strike, expiry, side }) {
            const normalizedSymbol = (symbol || '').toUpperCase();
            const normalizedSide = (side || '').toUpperCase();
            const strikeToken = Number.isFinite(strike) ? Number(strike).toFixed(2) : 'NA';
            const expiryToken = expiry || 'NA';
            return [normalizedSymbol || 'NA', strikeToken, expiryToken, normalizedSide || 'NA'].join('|');
        }

        function getDecisionStatusMeta(decision) {
            const map = {
                approve: { label: 'Buy', bg: '#ECFDF5', border: '#34D399', pillBg: '#D1FAE5', pillText: '#065F46' },
                caution: { label: 'Wait', bg: '#FFFBEB', border: '#FBBF24', pillBg: '#FEF3C7', pillText: '#92400E' },
                reject: { label: 'Ignore', bg: '#FEF2F2', border: '#F87171', pillBg: '#FECACA', pillText: '#991B1B' },
                unknown: { label: 'Monitor', bg: '#F8FAFC', border: '#94A3B8', pillBg: '#E2E8F0', pillText: '#0F172A' },
            };
            return map[decision] || map.unknown;
        }

        function loadTrackedIdeasFromStorage() {
            if (typeof localStorage === 'undefined') return [];
            try {
                const raw = localStorage.getItem(TRACKED_STORAGE_KEY);
                if (!raw) return [];
                const parsed = JSON.parse(raw);
                return Array.isArray(parsed) ? parsed : [];
            } catch (error) {
                console.warn('Failed to load tracked ideas, resetting state.', error);
                return [];
            }
        }

        function saveTrackedIdeasToStorage() {
            if (typeof localStorage === 'undefined') return;
            try {
                localStorage.setItem(TRACKED_STORAGE_KEY, JSON.stringify(trackedIdeas));
            } catch (error) {
                console.warn('Failed to persist tracked ideas.', error);
            }
        }

        function formatTrackedPrice(value) {
            return Number.isFinite(value) ? `$${Number(value).toFixed(2)}` : null;
        }

        function renderTrackedIdeas() {
            if (!trackedIdeasPanel || !trackedIdeasList || !trackedIdeasEmpty) return;
            const hasIdeas = Array.isArray(trackedIdeas) && trackedIdeas.length > 0;
            trackedIdeasEmpty.classList.toggle('hidden', hasIdeas);
            const tiles = hasIdeas
                ? trackedIdeas
                    .map((idea) => {
                        const meta = getDecisionStatusMeta(idea.decision);
                        const strikeLabel = idea.strike != null ? `$${Number(idea.strike).toFixed(2)}` : 'Strike TBD';
                        const expiryLabel = idea.expiry || 'Expiry TBD';
                        const sideLabel = (idea.side || '').toUpperCase() || 'CALL/PUT';
                        const priceBits = [];
                        const entryLabel = formatTrackedPrice(idea.entry);
                        const stopLabel = formatTrackedPrice(idea.stop);
                        const targetLabel = formatTrackedPrice(idea.target);
                        if (entryLabel) priceBits.push(`Entry ${entryLabel}`);
                        if (stopLabel) priceBits.push(`Stop ${stopLabel}`);
                        if (targetLabel) priceBits.push(`Target ${targetLabel}`);
                        const priceLine = priceBits.length ? priceBits.join(' • ') : 'No price targets set';
                        const summary = idea.summary ? `<div class="text-xs text-slate-600">${escapeHtml(idea.summary)}</div>` : '';
                        return `
                            <div class="tracked-idea-tile rounded-2xl border border-slate-200 p-3" style="background-color:${meta.bg};border-left-color:${meta.border};" data-idea-id="${escapeHtml(idea.id)}">
                                <div class="flex items-start justify-between gap-3">
                                    <div class="space-y-1">
                                        <div class="text-sm font-semibold text-slate-800">${escapeHtml(idea.symbol || '???')} <span class="text-xs font-normal text-slate-500">${escapeHtml(sideLabel)}</span></div>
                                        <div class="text-xs text-slate-500">${escapeHtml(strikeLabel)} • ${escapeHtml(expiryLabel)}</div>
                                        <div class="text-xs text-slate-500">${escapeHtml(priceLine)}</div>
                                        ${summary}
                                    </div>
                                    <div class="flex flex-col items-end gap-2">
                                        <span class="tracked-idea-pill inline-flex items-center px-2 py-1 rounded-full font-semibold" style="background-color:${meta.pillBg};color:${meta.pillText};">${escapeHtml(meta.label)}</span>
                                        <button type="button" class="text-[11px] uppercase tracking-wide text-slate-400 hover:text-slate-600" data-remove-idea="true" data-idea-id="${escapeHtml(idea.id)}">Remove</button>
                                    </div>
                                </div>
                            </div>
                        `;
                    })
                    .join('')
                : '';
            trackedIdeasList.innerHTML = tiles;
            if (clearTrackedIdeasBtn) {
                clearTrackedIdeasBtn.disabled = !hasIdeas;
                clearTrackedIdeasBtn.classList.toggle('opacity-50', !hasIdeas);
            }
            if (trackedIdeasStatus) {
                trackedIdeasStatus.textContent = hasIdeas
                    ? `${trackedIdeas.length} tracked ${trackedIdeas.length === 1 ? 'idea' : 'ideas'}`
                    : '';
            }
            lucide.createIcons();
        }

        function addTrackedIdea(payload) {
            if (!payload || !payload.id) return;
            const entry = {
                id: payload.id,
                symbol: payload.symbol || payload.ticker || '???',
                strike: Number.isFinite(payload.strike) ? Number(payload.strike) : null,
                expiry: payload.expiry || null,
                side: (payload.side || '').toUpperCase(),
                decision: normalizeDecision(payload.decision),
                summary: payload.summary || '',
                entry: Number.isFinite(payload.entry) ? Number(payload.entry) : null,
                stop: Number.isFinite(payload.stop) ? Number(payload.stop) : null,
                target: Number.isFinite(payload.target) ? Number(payload.target) : null,
                updatedAt: Date.now(),
            };
            const existingIndex = trackedIdeas.findIndex((idea) => idea.id === entry.id);
            if (existingIndex >= 0) {
                trackedIdeas[existingIndex] = entry;
            } else {
                trackedIdeas.unshift(entry);
                if (trackedIdeas.length > TRACKED_IDEA_LIMIT) {
                    trackedIdeas.splice(TRACKED_IDEA_LIMIT);
                }
            }
            saveTrackedIdeasToStorage();
            renderTrackedIdeas();
            syncTrackedIdeaButtons();
        }

        function removeTrackedIdea(ideaId) {
            if (!ideaId) return;
            const nextIdeas = trackedIdeas.filter((idea) => idea.id !== ideaId);
            if (nextIdeas.length === trackedIdeas.length) return;
            trackedIdeas = nextIdeas;
            saveTrackedIdeasToStorage();
            renderTrackedIdeas();
            syncTrackedIdeaButtons();
        }

        function clearTrackedIdeas() {
            if (!trackedIdeas.length) return;
            trackedIdeas = [];
            saveTrackedIdeasToStorage();
            renderTrackedIdeas();
            syncTrackedIdeaButtons();
        }

        function updateTrackButtonState(button, isTracked) {
            if (!button) return;
            button.dataset.trackState = isTracked ? 'tracked' : 'idle';
            button.setAttribute('aria-pressed', isTracked ? 'true' : 'false');
            button.textContent = isTracked ? 'Update Tile' : 'Track Idea';
        }

        function syncTrackedIdeaButtons() {
            if (!recommendations) return;
            const buttons = recommendations.querySelectorAll('button[data-track-idea]');
            buttons.forEach((button) => {
                const ideaId = button.dataset.ideaId;
                const isTracked = trackedIdeas.some((idea) => idea.id === ideaId);
                updateTrackButtonState(button, isTracked);
            });
        }

        trackedIdeas = loadTrackedIdeasFromStorage();
        renderTrackedIdeas();
        setTrackedPanelCollapsed(false);

        function getOptionSymbolFromPosition(position) {
            if (!position) return null;
            return position.optionSymbol || position.symbol || null;
        }

        function getAutoExitKey(position) {
            const baseSymbol = getOptionSymbolFromPosition(position) || 'UNKNOWN';
            const positionId = position?.positionId || '';
            return `${baseSymbol}|${positionId}`;
        }

        async function submitAutoExitOrder({ position, quantity, mode, reason }) {
            const accountIdKey = window.selectedAccountIdKey;
            if (!accountIdKey) throw new Error('No account loaded');
            const optionSymbol = getOptionSymbolFromPosition(position);
            if (!optionSymbol) throw new Error('Option symbol unavailable');
            const absQty = Math.abs(Math.trunc(quantity));
            if (!absQty) throw new Error('Invalid contract size for auto-exit');

            const payload = {
                optionSymbol,
                symbol: optionSymbol,
                quantity: absQty,
                callPut: position?.callPut || null,
                strike: position?.strike ?? null,
                expiry: position?.expiry || null,
            };

            const response = await fetch(`/api/portfolio/${accountIdKey}/options/emergency-sell`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(payload),
            });

            let data = null;
            try {
                data = await response.json();
            } catch (error) {
                data = null;
            }

            if (!response.ok || !data?.success) {
                const errorMessage = data?.error || `Broker rejected auto-exit (HTTP ${response.status})`;
                throw new Error(errorMessage);
            }

            const label = mode === 'stop' ? 'Emergency exit' : 'Scaling exit';
            setPortfolioStatus(`${label} triggered for ${optionSymbol} (${reason})`, 'warning');
            await loadAccountDetails(accountIdKey, { showLoading: false, reason: 'auto' });
            return data.order;
        }

        async function maybeAutoExitPosition(position) {
            if (!autoExitState.enabled || !position) return;
            const quantity = Number(position.quantity);
            if (!Number.isFinite(quantity) || quantity <= 0) return;
            const pnlPercent = Number(position.unrealizedGainLossPercent);
            if (!Number.isFinite(pnlPercent)) return;
            const cooldownKey = getAutoExitKey(position);
            const now = Date.now();
            const cooldownUntil = autoExitCooldowns.get(cooldownKey) || 0;
            if (cooldownUntil > now || autoExitPending.has(cooldownKey)) {
                return;
            }

            let mode = null;
            let qtyToSell = 0;
            let reason = '';
            const absQty = Math.abs(quantity);

            if (pnlPercent <= autoExitState.stopLossPct) {
                mode = 'stop';
                qtyToSell = absQty;
                reason = `PnL ${pnlPercent.toFixed(2)}% <= ${autoExitState.stopLossPct}%`;
            } else if (pnlPercent >= autoExitState.takeProfitPct) {
                mode = 'scale';
                const scaledQty = Math.max(
                    autoExitState.minContracts,
                    Math.floor(absQty * autoExitState.scalePct)
                );
                qtyToSell = Math.min(absQty, scaledQty);
                if (qtyToSell >= absQty) {
                    mode = 'stop';
                }
                reason = `PnL ${pnlPercent.toFixed(2)}% >= ${autoExitState.takeProfitPct}%`;
            } else {
                return;
            }

            if (!qtyToSell) return;

            autoExitPending.add(cooldownKey);
            const cooldownTarget = now + autoExitState.cooldownMs;
            autoExitCooldowns.set(cooldownKey, cooldownTarget);
            try {
                await submitAutoExitOrder({ position, quantity: qtyToSell, mode, reason });
            } catch (error) {
                console.error('Auto-exit order failed:', error);
                setPortfolioStatus(`Auto-exit failed for ${getOptionSymbolFromPosition(position)}: ${error.message}`, 'error');
                autoExitCooldowns.set(cooldownKey, now + Math.min(autoExitState.cooldownMs, 60000));
            } finally {
                autoExitPending.delete(cooldownKey);
            }
        }

        function evaluateAutoExitPositions(optionPositions) {
            if (!autoExitState.enabled) return;
            if (!Array.isArray(optionPositions) || !optionPositions.length) return;
            optionPositions.forEach((position) => {
                maybeAutoExitPosition(position).catch((error) => {
                    console.error('Auto-exit evaluation error:', error);
                });
            });
        }

        function setScanPanelCollapsed(collapsed) {
            if (!scanPanelBody || !toggleScanPanelBtn || !toggleScanPanelIcon || !toggleScanPanelLabel) return;
            scanPanelCollapsed = !!collapsed;
            if (scanPanelCollapsed) {
                scanPanelBody.classList.add('hidden');
                toggleScanPanelBtn.setAttribute('aria-expanded', 'false');
                toggleScanPanelIcon.setAttribute('data-lucide', 'chevron-down');
                toggleScanPanelLabel.textContent = 'Expand';
            } else {
                scanPanelBody.classList.remove('hidden');
                toggleScanPanelBtn.setAttribute('aria-expanded', 'true');
                toggleScanPanelIcon.setAttribute('data-lucide', 'chevron-up');
                toggleScanPanelLabel.textContent = 'Collapse';
            }
            lucide.createIcons();
        }

        if (toggleScanPanelBtn) {
            toggleScanPanelBtn.addEventListener('click', () => {
                setScanPanelCollapsed(!scanPanelCollapsed);
            });
        }

        setScanPanelCollapsed(false);

        function updateLayoutColumns() {
            if (!layoutGrid) return;
            if (leftSidebarCollapsed && rightSidebarCollapsed) {
                layoutGrid.style.gridTemplateColumns = 'minmax(0, 1fr)';
            } else if (leftSidebarCollapsed) {
                layoutGrid.style.gridTemplateColumns = 'minmax(0, 1fr) 360px';
            } else if (rightSidebarCollapsed) {
                layoutGrid.style.gridTemplateColumns = '320px minmax(0, 1fr)';
            } else {
                layoutGrid.style.gridTemplateColumns = '320px minmax(0, 1.4fr) 360px';
            }
        }

        function updateSidebarToggleUI() {
            if (collapseLeftIcon && collapseLeftLabel) {
                if (leftSidebarCollapsed) {
                    collapseLeftIcon.setAttribute('data-lucide', 'chevron-right');
                    collapseLeftLabel.textContent = 'Show Scan Panel';
                } else {
                    collapseLeftIcon.setAttribute('data-lucide', 'chevron-left');
                    collapseLeftLabel.textContent = 'Hide Scan Panel';
                }
            }
            if (collapseRightIcon && collapseRightLabel) {
                if (rightSidebarCollapsed) {
                    collapseRightIcon.setAttribute('data-lucide', 'chevron-left');
                    collapseRightLabel.textContent = 'Show Portfolio Rail';
                } else {
                    collapseRightIcon.setAttribute('data-lucide', 'chevron-right');
                    collapseRightLabel.textContent = 'Hide Portfolio Rail';
                }
            }
            lucide.createIcons();
        }

        function updateSidebarVisibility() {
            if (scanSidebar) {
                scanSidebar.style.display = leftSidebarCollapsed ? 'none' : '';
            }
            if (portfolioRail) {
                portfolioRail.style.display = rightSidebarCollapsed ? 'none' : '';
            }
            updateLayoutColumns();
            updateSidebarToggleUI();
        }

        if (collapseLeftBtn) {
            collapseLeftBtn.addEventListener('click', () => {
                leftSidebarCollapsed = !leftSidebarCollapsed;
                updateSidebarVisibility();
            });
        }

        if (collapseRightBtn) {
            collapseRightBtn.addEventListener('click', () => {
                rightSidebarCollapsed = !rightSidebarCollapsed;
                updateSidebarVisibility();
            });
        }

        updateSidebarVisibility();

        function formatSymbolSummary(list) {
            if (!Array.isArray(list) || list.length === 0) {
                return 'No symbols configured';
            }
            const preview = list.slice(0, 6);
            const suffix = list.length > preview.length ? '…' : '';
            const countLabel = `${list.length} symbol${list.length === 1 ? '' : 's'}`;
            return `${countLabel}: ${preview.join(', ')}${suffix}`;
        }

        const STRATEGY_METADATA = {
            day_trade: {
                label: 'Day Trade',
                description: 'Intraday focus with faster exits and 0DTE exposure.'
            },
            swing_trade: {
                label: 'Swing Trade',
                description: 'Multi-day positioning with weekly expirations.'
            }
        };

        function resolveStrategyMeta(strategy) {
            const key = typeof strategy === 'string' ? strategy.trim().toLowerCase() : '';
            return STRATEGY_METADATA[key] || {
                label: key || 'Unknown',
                description: 'Custom strategy mode.'
            };
        }

        function formatStrategyLabel(strategy) {
            return resolveStrategyMeta(strategy).label;
        }

        function formatStrategyDescription(strategy) {
            return resolveStrategyMeta(strategy).description;
        }

        function normalizeOptionSide(value, contract = '') {
            const token = typeof value === 'string' ? value.trim().toUpperCase() : '';
            if (token.includes('CALL') || token === 'C') return 'CALL';
            if (token.includes('PUT') || token === 'P') return 'PUT';
            const contractUpper = (contract || '').toUpperCase();
            if (contractUpper.includes(' CALL')) return 'CALL';
            if (contractUpper.includes(' PUT')) return 'PUT';
            if (/C\d{8}$/.test(contractUpper)) return 'CALL';
            if (/P\d{8}$/.test(contractUpper)) return 'PUT';
            return null;
        }

        function setStatusDisplay(target, state, message, { infoIcon = 'info' } = {}) {
            if (!target) return;
            const states = {
                loading: { icon: 'loader', color: 'text-blue-600', iconClass: 'animate-spin' },
                success: { icon: 'check', color: 'text-green-600', iconClass: '' },
                error: { icon: 'x', color: 'text-red-600', iconClass: '' },
                warning: { icon: 'alert-triangle', color: 'text-yellow-600', iconClass: '' },
                info: { icon: infoIcon, color: 'text-gray-600', iconClass: '' }
            };
            const meta = states[state] || states.info;
            const iconHtml = `<i data-lucide="${meta.icon}" class="w-4 h-4 ${meta.iconClass}"></i>`;
            target.innerHTML = `
                <div class="flex items-center gap-2 text-sm ${meta.color}">
                    ${iconHtml}
                    <span>${escapeHtml(message)}</span>
                </div>
            `;
            lucide.createIcons();
        }

        function setSymbolsStatus(state, message) {
            setStatusDisplay(symbolsStatus, state, message, { infoIcon: 'list' });
        }

        function setStrategyStatus(state, message) {
            setStatusDisplay(strategyStatus, state, message, { infoIcon: 'shuffle' });
        }

        if (trackedIdeasList) {
            trackedIdeasList.addEventListener('click', (event) => {
                const removeBtn = event.target.closest('button[data-remove-idea]');
                if (removeBtn) {
                    removeTrackedIdea(removeBtn.dataset.ideaId);
                }
            });
        }

        if (clearTrackedIdeasBtn) {
            clearTrackedIdeasBtn.addEventListener('click', () => {
                if (!trackedIdeas.length) return;
                if (window.confirm('Clear all tracked ideas?')) {
                    clearTrackedIdeas();
                }
            });
        }

        if (collapseTrackedIdeasBtn) {
            collapseTrackedIdeasBtn.addEventListener('click', () => setTrackedPanelCollapsed(true));
        }

        if (trackedIdeasToggleBtn) {
            trackedIdeasToggleBtn.addEventListener('click', () => setTrackedPanelCollapsed(false));
        }

        async function handleMarketBuyFromButton(button) {
            const accountIdKey = window.selectedAccountIdKey;
            if (!accountIdKey) {
                alert('Load your default account before placing orders.');
                return;
            }

            const entryPrice = Number(button.dataset.price);
            if (!Number.isFinite(entryPrice) || entryPrice <= 0) {
                alert('Unable to determine entry price for this contract.');
                return;
            }

            const withdrawCash = getWithdrawableCashValue();
            if (!Number.isFinite(withdrawCash) || withdrawCash <= 0) {
                alert('Withdrawable cash unavailable. Refresh your portfolio to sync balances.');
                return;
            }

            const optionSymbol = button.dataset.optionSymbol || button.dataset.symbol;
            const callPut = button.dataset.side ? button.dataset.side.toUpperCase() : null;
            const strike = button.dataset.strike ? Number(button.dataset.strike) : null;
            const expiry = button.dataset.expiry || null;
            const suggestedQty = button.dataset.quantity ? Number(button.dataset.quantity) : null;
            const hasSuggestedQty = Number.isFinite(suggestedQty) && suggestedQty > 0;

            if (!optionSymbol || !callPut || !strike || !expiry) {
                alert('Contract details missing (symbol/side/strike/expiry). Refresh scan to try again.');
                return;
            }

            const costPerContract = entryPrice * 100;
            const maxAffordableQty = Math.floor(withdrawCash / costPerContract);
            if (!maxAffordableQty) {
                alert('Withdrawable cash insufficient for at least one contract at this price.');
                return;
            }
            const canAffordSuggested = hasSuggestedQty && (suggestedQty * costPerContract) <= withdrawCash;
            const estimatedQty = hasSuggestedQty
                ? (canAffordSuggested ? suggestedQty : maxAffordableQty)
                : maxAffordableQty;

            const confirmLines = [
                `Account: ${accountIdKey}`,
                `Contract: ${optionSymbol || 'N/A'}`,
                `Side: ${callPut || 'CALL/PUT'} | Strike: ${strike || 'N/A'} | Exp: ${expiry || 'N/A'}`,
                `Entry (est): $${entryPrice.toFixed(2)} | Cost/contract: $${costPerContract.toFixed(2)}`,
                `Cash to withdraw: $${withdrawCash.toFixed(2)}`,
            ];
            if (hasSuggestedQty) {
                confirmLines.push(`AI suggested quantity: ${suggestedQty} contract${suggestedQty === 1 ? '' : 's'}${canAffordSuggested ? '' : ' (insufficient cash, will size down)'}`);
            }
            confirmLines.push(`Estimated quantity: ${estimatedQty} contract${estimatedQty === 1 ? '' : 's'}`);
            confirmLines.push('');
            confirmLines.push('Submit a market BUY order using withdrawable cash?');

            if (!window.confirm(confirmLines.join('\n'))) {
                return;
            }

            const payload = {
                optionSymbol,
                symbol: button.dataset.symbol || optionSymbol,
                price: entryPrice,
                callPut,
                strike,
                expiry,
                quantity: hasSuggestedQty ? suggestedQty : undefined,
            };

            const originalLabel = button.innerHTML;
            button.disabled = true;
            button.innerHTML = '<i data-lucide="loader" class="w-4 h-4 animate-spin"></i>';
            lucide.createIcons();

            try {
                const response = await fetch(`/api/portfolio/${accountIdKey}/options/market-buy`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload),
                });
                const data = await response.json().catch(() => null);
                if (!response.ok || !data?.success) {
                    const errorMessage = data?.error || `Order failed (HTTP ${response.status})`;
                    throw new Error(errorMessage);
                }
                alert(`Market buy submitted (${data.sizing?.quantity || '?'} contracts).`);
                await loadAccountDetails(accountIdKey, { showLoading: false, reason: 'auto' });
            } catch (error) {
                alert(`Market buy failed: ${error.message}`);
            } finally {
                button.disabled = false;
                button.innerHTML = originalLabel;
                lucide.createIcons();
            }
        }

        if (recommendations) {
            recommendations.addEventListener('click', (event) => {
                const buyBtn = event.target.closest('button[data-market-buy]');
                if (buyBtn) {
                    event.preventDefault();
                    handleMarketBuyFromButton(buyBtn);
                    return;
                }
                const trackButton = event.target.closest('button[data-track-idea]');
                if (!trackButton) return;
                event.preventDefault();
                const payload = {
                    id: trackButton.dataset.ideaId,
                    symbol: trackButton.dataset.symbol,
                    strike: trackButton.dataset.strike ? Number(trackButton.dataset.strike) : null,
                    expiry: trackButton.dataset.expiry || null,
                    side: trackButton.dataset.side || '',
                    decision: trackButton.dataset.decision || 'unknown',
                    entry: trackButton.dataset.entry ? Number(trackButton.dataset.entry) : null,
                    stop: trackButton.dataset.stop ? Number(trackButton.dataset.stop) : null,
                    target: trackButton.dataset.target ? Number(trackButton.dataset.target) : null,
                    summary: trackButton.dataset.summary || '',
                };
                if (!payload.id) {
                    payload.id = buildIdeaId(payload);
                }
                addTrackedIdea(payload);
                updateTrackButtonState(trackButton, true);
            });
        }

        function updateRecommendationSummary(stats) {
            if (!recommendationSummary) return;

            if (!stats || !stats.totalSymbols) {
                recommendationSummary.innerHTML = `
                    <div class="bg-white border border-dashed border-slate-200 rounded-xl p-5 flex items-center gap-3 text-slate-500">
                        <i data-lucide="compass" class="w-5 h-5"></i>
                        <div>
                            <div class="text-sm font-semibold">Awaiting trade ideas</div>
                            <div class="text-xs text-slate-400">Run a scan to populate AI suggestions.</div>
                        </div>
                    </div>
                `;
                lucide.createIcons();
                return;
            }

            const cards = [
                {
                    icon: 'radar',
                    title: 'Trade Ideas',
                    value: stats.totalSymbols,
                    accent: 'text-blue-600',
                    description: `${stats.totalIdeas} AI reads · ${stats.providerCount} providers`,
                },
                {
                    icon: 'check-circle',
                    title: 'Approved',
                    value: stats.decisionCounts.approve,
                    accent: 'text-emerald-600',
                    description: `${stats.callPutCounts.call} calls · ${stats.callPutCounts.put} puts`,
                },
                {
                    icon: 'alert-triangle',
                    title: 'Caution',
                    value: stats.decisionCounts.caution,
                    accent: 'text-amber-600',
                    description: `${stats.decisionCounts.reject} rejects · ${stats.decisionCounts.unknown} needs review`,
                },
                {
                    icon: 'shield-alert',
                    title: 'Risk Flags',
                    value: stats.riskFlagSymbols.length,
                    accent: 'text-rose-600',
                    description: `${stats.totalRiskFlags} alerts across watchlist`,
                },
            ];

            recommendationSummary.innerHTML = cards
                .map((card) => `
                    <div class="bg-white rounded-xl border border-slate-200 shadow-sm p-5 flex items-start gap-3">
                        <div class="shrink-0 rounded-lg bg-slate-100 p-2">
                            <i data-lucide="${card.icon}" class="w-5 h-5 ${card.accent}"></i>
                        </div>
                        <div class="space-y-1">
                            <div class="text-xs font-semibold uppercase tracking-wide text-slate-400">${escapeHtml(card.title)}</div>
                            <div class="text-2xl font-bold ${card.accent}">${escapeHtml(String(card.value))}</div>
                            <div class="text-xs text-slate-500">${escapeHtml(card.description)}</div>
                        </div>
                    </div>
                `)
                .join('');

            lucide.createIcons();
        }

        function renderSidebarInsights() {
            if (!scanInsights) return;

            const insights = [];
            const strategyLabel = formatStrategyLabel(currentStrategy);
            const symbolSummary = escapeHtml(formatSymbolSummary(currentSymbolList));

            insights.push(`
                <li class="flex items-start gap-2">
                    <i data-lucide="list" class="w-4 h-4 text-slate-500 mt-0.5"></i>
                    <span><span class="font-semibold text-slate-700">${symbolSummary}</span></span>
                </li>
            `);

            insights.push(`
                <li class="flex items-start gap-2">
                    <i data-lucide="shuffle" class="w-4 h-4 text-indigo-500 mt-0.5"></i>
                    <span><span class="font-semibold text-slate-700">${escapeHtml(strategyLabel)}</span> strategy active</span>
                </li>
            `);

            if (lastRecommendationStats) {
                const stats = lastRecommendationStats;
                const formatDecisionLabel = (value) => {
                    if (!value) return '';
                    return String(value)
                        .replace(/[_-]+/g, ' ')
                        .replace(/\b\w/g, (char) => char.toUpperCase());
                };
                insights.push(`
                    <li class="flex items-start gap-2">
                        <i data-lucide="sparkles" class="w-4 h-4 text-emerald-500 mt-0.5"></i>
                        <span>${escapeHtml(String(stats.totalSymbols))} symbols · ${escapeHtml(String(stats.totalIdeas))} AI reads · ${escapeHtml(String(stats.providerCount))} providers</span>
                    </li>
                `);

                const decisionSummary = Object.entries(stats.decisionCounts || {})
                    .filter(([, count]) => Number(count) > 0)
                    .map(([key, count]) => `${escapeHtml(String(count))} ${escapeHtml(formatDecisionLabel(key))}`)
                    .join(' · ');
                if (decisionSummary) {
                    insights.push(`
                        <li class="flex items-start gap-2">
                            <i data-lucide="scale" class="w-4 h-4 text-indigo-500 mt-0.5"></i>
                            <span>${decisionSummary}</span>
                        </li>
                    `);
                }

                const cp = stats.callPutCounts || {};
                if ((cp.call || 0) > 0 || (cp.put || 0) > 0) {
                    insights.push(`
                        <li class="flex items-start gap-2">
                            <i data-lucide="columns" class="w-4 h-4 text-slate-500 mt-0.5"></i>
                            <span>${escapeHtml(String(cp.call || 0))} calls · ${escapeHtml(String(cp.put || 0))} puts</span>
                        </li>
                    `);
                }

                if (stats.topSignals.length) {
                    const signalText = stats.topSignals
                        .map((sig) => `${escapeHtml(sig.name)} (${escapeHtml(String(sig.count))})`)
                        .join(', ');
                    insights.push(`
                        <li class="flex items-start gap-2">
                            <i data-lucide="activity" class="w-4 h-4 text-blue-500 mt-0.5"></i>
                            <span>Top signals: ${signalText}</span>
                        </li>
                    `);
                }

                if (stats.riskFlagSymbols.length) {
                    const risky = stats.riskFlagSymbols
                        .slice(0, 3)
                        .map((sym) => escapeHtml(sym))
                        .join(', ');
                    const suffix = stats.riskFlagSymbols.length > 3 ? '…' : '';
                    insights.push(`
                        <li class="flex items-start gap-2">
                            <i data-lucide="alert-octagon" class="w-4 h-4 text-rose-500 mt-0.5"></i>
                            <span>Risk alerts on ${escapeHtml(String(stats.riskFlagSymbols.length))} symbols (${risky}${suffix})</span>
                        </li>
                    `);
                }
            }

            if (lastScanMetaPayload) {
                const providerLabel = Array.isArray(lastScanMetaPayload.providers)
                    ? lastScanMetaPayload.providers
                        .map((p) => (p && typeof p === 'object' ? p.provider || '' : p))
                        .filter(Boolean)
                        .map((name) => escapeHtml(String(name).toUpperCase()))
                        .join(', ')
                    : null;
                const lastRun = lastScanMetaPayload.completedAt
                    ? `Last scan ${escapeHtml(formatRelativeTime(lastScanMetaPayload.completedAt))}`
                    : 'Scan pending';
                const providerDetail = providerLabel ? ` · ${providerLabel}` : '';
                insights.push(`
                    <li class="flex items-start gap-2">
                        <i data-lucide="history" class="w-4 h-4 text-slate-500 mt-0.5"></i>
                        <span>${lastRun}${providerDetail}</span>
                    </li>
                `);

                const failureCount = Array.isArray(lastScanMetaPayload.errors)
                    ? lastScanMetaPayload.errors.filter((err) => err && (err.provider || err.message)).length
                    : 0;
                if (failureCount) {
                    insights.push(`
                        <li class="flex items-start gap-2">
                            <i data-lucide="alert-circle" class="w-4 h-4 text-amber-500 mt-0.5"></i>
                            <span>${escapeHtml(String(failureCount))} provider${failureCount === 1 ? '' : 's'} reported errors</span>
                        </li>
                    `);
                }
            }

            if (!insights.length) {
                insights.push(`
                    <li class="flex items-start gap-2">
                        <i data-lucide="info" class="w-4 h-4 text-slate-400 mt-0.5"></i>
                        <span>Awaiting initial scan...</span>
                    </li>
                `);
            }

            scanInsights.innerHTML = insights.join('');
            lucide.createIcons();
        }

        const SENSITIVE_MASK = '****';

        function maskAccountId(value) {
            const str = value != null ? String(value) : 'N/A';
            if (!str || str === 'N/A') {
                return 'N/A';
            }
            const alphanumeric = str.replace(/[^A-Za-z0-9]/g, '');
            const tail = alphanumeric.slice(-4) || str.slice(-4) || '----';
            return `${SENSITIVE_MASK}${tail}`;
        }

        function getCurrencyString(value) {
            if (!Number.isFinite(value)) {
                return revealSensitive ? 'N/A' : `$${SENSITIVE_MASK}`;
            }
            const formatted = `$${value.toFixed(2)}`;
            return revealSensitive ? formatted : `$${SENSITIVE_MASK}`;
        }

        function getAccountIdString(value) {
            const str = value != null ? String(value) : 'N/A';
            return revealSensitive ? str : maskAccountId(str);
        }

        function initDayPlPanel() {
            if (!dayPlPanel) {
                return;
            }
            dayPlPanel.classList.remove('hidden');
            document.body.classList.add('day-pl-panel-open');
            if (dayPlToggleHandle) {
                dayPlToggleHandle.addEventListener('click', () => toggleDayPlPanel());
            }
            if (dayPlRevealBtn) {
                dayPlRevealBtn.addEventListener('click', () => toggleDayPlPanel(true));
            }
            renderDayPlPanel(null);
        }

        function toggleDayPlPanel(forceOpen = null) {
            if (!dayPlPanel) {
                return;
            }
            const nextState = forceOpen != null ? forceOpen : !dayPlPanelOpen;
            dayPlPanelOpen = nextState;
            dayPlPanel.classList.toggle('translate-x-full', !nextState);
            if (dayPlRevealBtn) {
                dayPlRevealBtn.classList.toggle('hidden', nextState);
            }
            const toggleLabel = dayPlToggleHandle?.querySelector('span');
            if (toggleLabel) {
                toggleLabel.textContent = nextState ? 'Hide' : 'Show';
            }
            document.body.classList.toggle('day-pl-panel-open', nextState);
        }

        function buildDayPlSnapshot(portfolio, dayOrders = null) {
            const optionPositions = Array.isArray(portfolio?.positions)
                ? portfolio.positions.filter((position) => {
                    if (!position) return false;
                    const type = (position.positionType || '').toUpperCase();
                    return Boolean(position.optionSymbol || position.callPut || type.includes('OPTION'));
                })
                : [];
            const enriched = optionPositions.map((position) => {
                const totalCost = Number(position.totalCost || 0);
                const marketValue = Number(position.marketValue || 0);
                const basePl = Number.isFinite(position.unrealizedGainLoss)
                    ? position.unrealizedGainLoss
                    : marketValue - totalCost;
                const dayPl = Number(basePl.toFixed(2));
                const dayPlPct = totalCost !== 0 ? Number(((dayPl / totalCost) * 100).toFixed(2)) : null;
                return {
                    symbol: position.symbol,
                    optionSymbol: position.optionSymbol || position.osiKey || null,
                    qty: Number(position.quantity || 0),
                    strike: position.strike,
                    expiry: position.expiry,
                    side: position.callPut,
                    marketValue: Number(marketValue.toFixed(2)),
                    totalCost: Number(totalCost.toFixed(2)),
                    dayPl,
                    dayPlPct,
                };
            }).sort((a, b) => Math.abs(b.dayPl) - Math.abs(a.dayPl));

            const openTotals = enriched.reduce((acc, row) => {
                acc.totalCost += row.totalCost || 0;
                acc.marketValue += row.marketValue || 0;
                acc.open += row.dayPl || 0;
                return acc;
            }, { totalCost: 0, marketValue: 0, open: 0 });

            openTotals.totalCost = Number(openTotals.totalCost.toFixed(2));
            openTotals.marketValue = Number(openTotals.marketValue.toFixed(2));
            openTotals.open = Number(openTotals.open.toFixed(2));

            const realizedTotals = {
                realized: Number(dayOrders?.totals?.realized ?? 0),
                grossBuys: Number(dayOrders?.totals?.grossBuys ?? 0),
                grossSells: Number(dayOrders?.totals?.grossSells ?? 0),
            };

            const combined = Number((openTotals.open + realizedTotals.realized).toFixed(2));

            return {
                updatedAt: dayOrders?.updatedAt || new Date().toISOString(),
                positions: enriched,
                totals: {
                    totalCost: openTotals.totalCost,
                    marketValue: openTotals.marketValue,
                    open: openTotals.open,
                    realized: realizedTotals.realized,
                    combined,
                    grossBuys: realizedTotals.grossBuys,
                    grossSells: realizedTotals.grossSells,
                },
                orders: Array.isArray(dayOrders?.trades) ? dayOrders.trades : [],
            };
        }

        function renderDayPlPanel(snapshot) {
            if (!dayPlPanel) {
                return;
            }
            lastDayPlSnapshot = snapshot;
            if (!snapshot) {
                if (dayPlTotal) dayPlTotal.textContent = '$0.00';
                if (dayPlSummaryMeta) dayPlSummaryMeta.textContent = 'Day P/L requires an active portfolio.';
                if (dayPlUpdatedAt) dayPlUpdatedAt.textContent = 'Awaiting portfolio sync...';
                if (dayPlPositions) {
                    dayPlPositions.innerHTML = '<div class="p-5 text-sm text-slate-500">Connect your brokerage account to view live option P/L.</div>';
                }
                return;
            }

            const totals = snapshot.totals || { open: 0, realized: 0, combined: 0 };

            if (dayPlTotal) {
                dayPlTotal.classList.remove('text-emerald-600', 'text-rose-600');
                const signClass = totals.combined >= 0 ? 'text-emerald-600' : 'text-rose-600';
                dayPlTotal.classList.add(signClass);
                dayPlTotal.textContent = getCurrencyString(totals.combined);
            }
            if (dayPlSummaryMeta) {
                const countLabel = snapshot.positions.length === 1 ? 'position' : 'positions';
                const realizedLabel = `Realized ${getCurrencyString(totals.realized)}`;
                const openLabel = `Open ${getCurrencyString(totals.open)}`;
                dayPlSummaryMeta.textContent = `${snapshot.positions.length} option ${countLabel} • ${realizedLabel} • ${openLabel}`;
            }
            if (dayPlUpdatedAt) {
                dayPlUpdatedAt.textContent = snapshot.updatedAt ? `Updated ${formatRelativeTime(snapshot.updatedAt)}` : 'Updated just now';
            }

            if (dayPlPositions) {
                const positionsHtml = snapshot.positions.length
                    ? snapshot.positions.map((pos) => {
                        const directionClass = pos.dayPl >= 0 ? 'text-emerald-600' : 'text-rose-600';
                        const qtyLabel = `${pos.qty} contract${Math.abs(pos.qty) === 1 ? '' : 's'}`;
                        const details = [
                            pos.side ? pos.side.toUpperCase() : null,
                            pos.strike != null ? `@ ${pos.strike}` : null,
                            pos.expiry || null,
                        ].filter(Boolean).join(' | ');
                        return `
                            <div class="px-4 py-3 flex items-center justify-between gap-4">
                                <div>
                                    <div class="text-sm font-semibold text-slate-800">${escapeHtml(pos.symbol || 'Option')}</div>
                                    <div class="text-xs text-slate-500">${escapeHtml(details || 'Option contract')}</div>
                                    <div class="text-[11px] uppercase tracking-wide text-slate-400 mt-1">${escapeHtml(qtyLabel)}</div>
                                </div>
                                <div class="text-right">
                                    <div class="text-sm font-semibold ${directionClass}">${getCurrencyString(pos.dayPl)}</div>
                                    <div class="text-xs text-slate-500">${pos.dayPlPct != null ? `${pos.dayPlPct > 0 ? '+' : ''}${pos.dayPlPct.toFixed(2)}%` : '&mdash;'}</div>
                                </div>
                            </div>
                        `;
                    }).join('')
                    : '<div class="p-4 text-sm text-slate-500">No open option positions.</div>';

                const ordersHtml = snapshot.orders && snapshot.orders.length
                    ? snapshot.orders.map((order) => {
                        const netClass = order.netCash >= 0 ? 'text-emerald-600' : 'text-rose-600';
                        const qtyLabel = `${order.qty} contract${Math.abs(order.qty) === 1 ? '' : 's'}`;
                        const timeLabel = order.timestamp ? formatRelativeTime(order.timestamp) : 'Today';
                        const metaParts = [
                            order.side || null,
                            order.strike != null ? `@ ${order.strike}` : null,
                            order.expiry || null,
                        ].filter(Boolean).join(' • ');
                        const realizedLabel = order.realized != null
                            ? `<div class="text-[11px] text-slate-500">Realized ${getCurrencyString(order.realized)}</div>`
                            : '';
                        const unmatchedLabel = order.unmatchedQty > 0
                            ? `<div class="text-[11px] text-amber-600">Unmatched ${order.unmatchedQty} contract${order.unmatchedQty === 1 ? '' : 's'}</div>`
                            : '';
                        return `
                            <div class="px-4 py-3 flex items-center justify-between gap-4">
                                <div>
                                    <div class="text-sm font-semibold text-slate-800">${escapeHtml(order.description || order.optionSymbol || 'Executed order')}</div>
                                    <div class="text-xs text-slate-500">${escapeHtml(metaParts || qtyLabel)}</div>
                                    <div class="text-[11px] uppercase tracking-wide text-slate-400 mt-1">${escapeHtml(timeLabel)}</div>
                                    ${realizedLabel}
                                    ${unmatchedLabel}
                                </div>
                                <div class="text-right">
                                    <div class="text-sm font-semibold ${netClass}">${getCurrencyString(order.netCash)}</div>
                                    <div class="text-xs text-slate-500">${order.price ? `Avg ${order.price.toFixed(2)}` : '&mdash;'}</div>
                                </div>
                            </div>
                        `;
                    }).join('')
                    : '<div class="p-4 text-sm text-slate-500">No executed option orders yet today.</div>';

                dayPlPositions.innerHTML = `
                    <section class="pb-4">
                        <div class="text-xs uppercase tracking-wide text-slate-400 px-4 pb-2">Open Positions</div>
                        <div class="divide-y divide-slate-100">
                            ${positionsHtml}
                        </div>
                    </section>
                    <section class="border-t border-slate-200 pt-4">
                        <div class="text-xs uppercase tracking-wide text-slate-400 px-4 pb-2">Executed Orders</div>
                        <div class="divide-y divide-slate-100">
                            ${ordersHtml}
                        </div>
                    </section>
                `;
            }

            lucide.createIcons();
        }

        function updateDayPlPanelData(portfolio, dayOrders = null) {
            if (!dayPlPanel) {
                return;
            }
            const snapshot = buildDayPlSnapshot(portfolio, dayOrders || lastDayOrdersPayload);
            renderDayPlPanel(snapshot);
        }
        function renderHeaderBalance() {
            if (!headerBalance) return;
            const rawValue = Number(lastBalancePayload?.totalAccountValue);
            const safeValue = Number.isFinite(rawValue) ? rawValue : null;
            headerBalance.textContent = getCurrencyString(safeValue);
            const cashValue = Number(
                lastBalancePayload?.cashAvailableForInvestment ??
                lastBalancePayload?.moneyMktBalance ??
                lastBalancePayload?.cashBalance ??
                lastBalancePayload?.cash
            );
            const cashLabel = getCurrencyString(Number.isFinite(cashValue) ? cashValue : null);
            if (headerAvailableCash) {
                headerAvailableCash.textContent = `Available Cash: ${cashLabel}`;
            }
            const withdrawValue = Number(
                lastBalancePayload?.cashAvailableForWithdrawal ??
                lastBalancePayload?.cashAvailableToWithdraw ??
                lastBalancePayload?.fundsForWithdrawal ??
                lastBalancePayload?.cashAvailable ?? null
            );
            const withdrawLabel = getCurrencyString(Number.isFinite(withdrawValue) ? withdrawValue : null);
            if (headerCashWithdraw) {
                headerCashWithdraw.textContent = `Cash To Withdraw: ${withdrawLabel}`;
            }
        }

        function getWithdrawableCashValue() {
            const cash = Number(
                lastBalancePayload?.totalAvailableForWithdrawal
                ?? lastBalancePayload?.cashAvailableForWithdrawal
                ?? lastBalancePayload?.cashAvailableToWithdraw
                ?? lastBalancePayload?.fundsForWithdrawal
                ?? lastBalancePayload?.cashAvailable
                ?? lastBalancePayload?.cashBalance
                ?? lastBalancePayload?.cash
            );
            return Number.isFinite(cash) ? cash : null;
        }

        function refreshPortfolioDisplay() {
            if (lastPortfolioPayload) {
                displayPortfolio(lastPortfolioPayload, lastPortfolioBalance, {
                    skipStore: true,
                    dayOrders: lastDayOrdersPayload,
                });
            }
        }

        function setPortfolioStatus(message, tone = 'info') {
            if (!portfolioStatus) return;
            const toneClassMap = {
                info: 'text-gray-500',
                success: 'text-green-600',
                warning: 'text-amber-600',
                error: 'text-red-600',
            };
            portfolioStatus.textContent = message || '';
            portfolioStatus.classList.remove('text-gray-500', 'text-green-600', 'text-amber-600', 'text-red-600');
            if (message) {
                portfolioStatus.classList.add(toneClassMap[tone] || toneClassMap.info);
                portfolioStatus.classList.remove('hidden');
            } else {
                portfolioStatus.classList.add('hidden');
            }
        }

        function clearPortfolioRefreshTimer() {
            if (portfolioRefreshTimer) {
                clearInterval(portfolioRefreshTimer);
                portfolioRefreshTimer = null;
            }
        }

        function schedulePortfolioRefresh(accountIdKey) {
            clearPortfolioRefreshTimer();
            if (!accountIdKey) {
                return;
            }
            portfolioRefreshTimer = setInterval(() => {
                loadAccountDetails(accountIdKey, { showLoading: false, reason: 'auto' });
            }, PORTFOLIO_REFRESH_INTERVAL_MS);
        }

        function formatRefreshTimestamp(timestamp) {
            if (!timestamp) {
                return '';
            }
            return new Date(timestamp).toLocaleTimeString([], { hour: '2-digit', minute: '2-digit', second: '2-digit' });
        }

        setPortfolioStatus('');

        function updateSensitiveControls() {
            if (!toggleSensitiveBtn) return;
            const iconName = revealSensitive ? 'eye' : 'eye-off';
            const label = revealSensitive ? 'Hide Details' : 'Show Details';
            toggleSensitiveBtn.innerHTML = `
                <i data-lucide="${iconName}" class="w-4 h-4"></i>
                <span>${label}</span>
            `;
            lucide.createIcons();
        }

        if (toggleSensitiveBtn) {
            updateSensitiveControls();
            toggleSensitiveBtn.addEventListener('click', () => {
                revealSensitive = !revealSensitive;
                updateSensitiveControls();
                renderHeaderBalance();
                refreshPortfolioDisplay();
            });
        }

        function applyScanConfig(config, options = {}) {
            const { updateInput = false, updateStatus = true } = options;
            if (!config) return;
            const list = Array.isArray(config.symbols) ? config.symbols : [];
            currentSymbolList = list;
            const configuredStrategy = typeof config.strategy === 'string' ? config.strategy : currentStrategy;
            currentStrategy = configuredStrategy;
            if (strategySelect && strategySelect.value !== configuredStrategy) {
                strategySelect.value = configuredStrategy;
            }
            if (updateInput && symbolsInput && document.activeElement !== symbolsInput) {
                symbolsInput.value = list.join(', ');
            }
            if (updateStatus) {
                if (list.length === 0) {
                    setSymbolsStatus('warning', 'No symbols configured. Add tickers to start scanning.');
                } else {
                    setSymbolsStatus('info', formatSymbolSummary(list));
                }
                const strategyLabel = formatStrategyLabel(configuredStrategy);
                const strategyDescription = formatStrategyDescription(configuredStrategy);
                setStrategyStatus('info', `${strategyLabel} • ${strategyDescription}`);
            }
            renderSidebarInsights();
        }

        function renderScanStatus({ icon, color = 'text-gray-600', message, suffix = '', iconClass = '' }) {
            if (!scanStatus) return;
            scanStatus.innerHTML = `
                <div class="flex items-center gap-2 ${color}">
                    <i data-lucide="${icon}" class="w-4 h-4 ${iconClass}"></i>
                    <span>${escapeHtml(message)}</span>
                    ${suffix}
                </div>
            `;
            lucide.createIcons();
        }

        function formatRelativeTime(isoString) {
            if (!isoString) {
                return 'never';
            }

            const deltaMs = Date.now() - Date.parse(isoString);
            if (!Number.isFinite(deltaMs) || deltaMs < 0) {
                return new Date(isoString).toLocaleTimeString();
            }

            const seconds = Math.floor(deltaMs / 1000);
            if (seconds < 60) {
                return `${seconds}s ago`;
            }

            const minutes = Math.floor(seconds / 60);
            if (minutes < 60) {
                return `${minutes}m ago`;
            }

            const hours = Math.floor(minutes / 60);
            return `${hours}h ago`;
        }

        function updateScanStatus(payload, error) {
            if (payload?.config) {
                applyScanConfig(payload.config, { updateInput: false, updateStatus: true });
            }

            if (payload?.scanMeta) {
                lastScanMetaPayload = payload.scanMeta;
            } else if (payload?.results?.scanMeta) {
                lastScanMetaPayload = payload.results.scanMeta;
            }

            const symbolSuffix = currentSymbolList.length
                ? `<span class="text-xs text-gray-400 ml-2">[${escapeHtml(currentSymbolList.join(', '))}]</span>`
                : '';
            const strategyLabel = formatStrategyLabel(currentStrategy);
            const strategySuffix = currentStrategy
                ? `<span class="text-xs text-indigo-500 ml-2 uppercase">Strategy: ${escapeHtml(strategyLabel)}</span>`
                : '';
            const statusSuffix = `${symbolSuffix}${strategySuffix}`;

            const finish = () => {
                renderSidebarInsights();
            };

            if (error) {
                renderScanStatus({ icon: 'x', color: 'text-red-600', message: error, suffix: statusSuffix });
                finish();
                return;
            }

            if (!payload) {
                renderScanStatus({ icon: 'clock', message: 'Waiting for first scan', suffix: symbolSuffix });
                finish();
                return;
            }

            const { isScanning, scanMeta, lastError } = payload;

            if (isScanning) {
                renderScanStatus({ icon: 'loader', color: 'text-blue-600', iconClass: 'animate-spin', message: `Running ${strategyLabel} scan...`, suffix: statusSuffix });
                finish();
                return;
            }

            if (scanMeta?.success) {
                const completed = formatRelativeTime(scanMeta.completedAt);
                const sourceLabel = scanMeta.source || 'auto';
                const providerList = Array.isArray(scanMeta.providers)
                    ? scanMeta.providers.map((p) => (p && typeof p === 'object' ? p.provider || '' : p)).filter(Boolean)
                    : Array.isArray(payload?.results?.providers)
                        ? payload.results.providers.map((p) => (p && typeof p === 'object' ? p.provider || '' : p)).filter(Boolean)
                        : [];
                const providerLabel = providerList.length
                    ? ` | AI: ${providerList.map((name) => String(name).toUpperCase()).join(', ')}`
                    : '';
                const failureCount = Array.isArray(scanMeta.errors)
                    ? scanMeta.errors.filter((err) => err && err.provider && err.message).length
                    : 0;
                const failureLabel = failureCount
                    ? ` | ${failureCount} provider${failureCount === 1 ? '' : 's'} failed`
                    : '';
                renderScanStatus({
                    icon: 'check',
                    color: 'text-green-600',
                    message: `Last scan ${completed} (${sourceLabel}${providerLabel}${failureLabel})`,
                    suffix: statusSuffix
                });
                finish();
                return;
            }

            if (scanMeta && !scanMeta.success) {
                const completed = formatRelativeTime(scanMeta.completedAt);
                const errorMessage = lastError?.message || 'Scan failed';
                renderScanStatus({
                    icon: 'alert-triangle',
                    color: 'text-yellow-600',
                    message: `Scan error ${completed}: ${errorMessage}`,
                    suffix: statusSuffix
                });
                finish();
                return;
            }

            renderScanStatus({ icon: 'clock', message: 'Waiting for first scan', suffix: statusSuffix });
            finish();
        }

        async function fetchRecommendations() {
            try {
                const response = await fetch('/api/recommendations');
                const data = await response.json();

                if (data.results) {
                    displayRecommendations(data.results.parsed, data.results);
                }

                updateScanStatus(data);
            } catch (err) {
                console.error('Failed to fetch recommendations:', err);
                updateScanStatus(null, 'Disconnected from scanner');
            }
        }

        function startRecommendationsPolling() {
            if (recommendationsTimer) {
                return;
            }

            recommendationsTimer = setInterval(fetchRecommendations, POLL_INTERVAL_MS);
        }

        // Scan for trades
        scanBtn.addEventListener('click', async () => {
            scanBtn.disabled = true;
            scanBtn.innerHTML = '<i data-lucide="loader" class="w-5 h-5 animate-spin"></i> Scanning...';
            lucide.createIcons();
            const suffix = currentSymbolList.length
                ? `<span class="text-xs text-gray-400 ml-2">[${escapeHtml(currentSymbolList.join(', '))}]</span>`
                : '';
            const strategyLabel = formatStrategyLabel(currentStrategy);
            const strategySuffix = currentStrategy
                ? `<span class="text-xs text-indigo-500 ml-2 uppercase">Strategy: ${escapeHtml(strategyLabel)}</span>`
                : '';
            renderScanStatus({
                icon: 'loader',
                color: 'text-blue-600',
                iconClass: 'animate-spin',
                message: `Running manual ${strategyLabel} scan...`,
                suffix: `${suffix}${strategySuffix}`
            });

            try {
                const response = await fetch('/api/scan', { method: 'POST' });
                const data = await response.json();

                if (data.success) {
                    await fetchRecommendations();
                } else {
                    throw new Error(data.error);
                }
            } catch (error) {
                console.error('Scan failed:', error);
                const alreadyRunning = error.message === 'Scan already in progress';
                const msg = alreadyRunning ? 'Scan already running, please wait...' : 'Manual scan failed: ' + error.message;
                updateScanStatus(null, msg);
            } finally {
                scanBtn.disabled = false;
                scanBtn.innerHTML = '<i data-lucide="search" class="w-5 h-5"></i> Scan for Trades';
                lucide.createIcons();
            }
        });

        if (saveSymbolsBtn) {
            saveSymbolsBtn.addEventListener('click', async () => {
                await saveScanSettings();
            });
        }

        if (symbolsInput) {
            symbolsInput.addEventListener('keydown', async (event) => {
                if (event.key === 'Enter' && !event.shiftKey) {
                    event.preventDefault();
                    await saveScanSettings();
                }
            });
        }

        if (strategySelect) {
            strategySelect.addEventListener('change', async () => {
                await saveScanSettings();
            });
        }

        let portfolioConfigLoaded = false;
        const portfolioConfig = { defaultAccountIdKey: null, autoExit: autoExitState };

        function applyAutoExitConfig(config) {
            if (!config) return;
            autoExitState.enabled = Boolean(config.enabled);

            const parseNumber = (value, fallback) => {
                const numeric = Number(value);
                return Number.isFinite(numeric) ? numeric : fallback;
            };

            autoExitState.takeProfitPct = parseNumber(config.takeProfitPct, autoExitDefaults.takeProfitPct);
            autoExitState.stopLossPct = parseNumber(config.stopLossPct, autoExitDefaults.stopLossPct);
            const scalePct = parseNumber(config.scalePct, autoExitDefaults.scalePct);
            autoExitState.scalePct = Math.min(Math.max(scalePct, 0.05), 1);
            const minContracts = parseNumber(config.minContracts, autoExitDefaults.minContracts);
            autoExitState.minContracts = Math.max(1, Math.trunc(minContracts));
            autoExitState.cooldownMs = Math.max(0, parseNumber(config.cooldownMs, autoExitDefaults.cooldownMs));
        }

        async function loadPortfolioConfig() {
            if (portfolioConfigLoaded) {
                return portfolioConfig;
            }
            try {
                const response = await fetch('/api/portfolio/config');
                if (response.ok) {
                    const data = await response.json();
                    if (data?.success) {
                        if (data.defaultAccountIdKey) {
                            portfolioConfig.defaultAccountIdKey = data.defaultAccountIdKey;
                        }
                        if (data.autoExit) {
                            applyAutoExitConfig(data.autoExit);
                        }
                    }
                }
            } catch (error) {
                console.warn('Portfolio config fetch failed:', error);
            } finally {
                portfolioConfigLoaded = true;
            }
            return portfolioConfig;
        }

        function resolveDefaultAccountIdKey(accounts) {
            if (!Array.isArray(accounts) || accounts.length === 0) {
                return null;
            }
            if (portfolioConfig.defaultAccountIdKey) {
                const match = accounts.find((acc) => acc.accountIdKey === portfolioConfig.defaultAccountIdKey);
                if (match) {
                    return match.accountIdKey;
                }
            }
            return accounts[0].accountIdKey;
        }

        function revealPortfolioRail() {
            if (portfolioRail) {
                portfolioRail.classList.remove('hidden');
            }
        }

        function renderPortfolioLoadingState() {
            if (accountSummary) {
                accountSummary.innerHTML = `
                    <div class="col-span-2 flex items-center justify-center py-6">
                        <div class="flex items-center gap-2 text-slate-500">
                            <i data-lucide="loader" class="w-4 h-4 animate-spin text-blue-500"></i>
                            <span>Loading account details…</span>
                        </div>
                    </div>
                `;
            }
            if (portfolioOptionsList) {
                portfolioOptionsList.innerHTML = `
                    <div class="border border-dashed border-slate-200 rounded-lg p-4 animate-pulse bg-slate-50">
                        <div class="h-3 bg-slate-200 rounded w-1/2 mb-3"></div>
                        <div class="space-y-2">
                            <div class="h-2.5 bg-slate-200 rounded"></div>
                            <div class="h-2.5 bg-slate-200 rounded"></div>
                            <div class="h-2.5 bg-slate-200 rounded w-2/3"></div>
                        </div>
                    </div>
                `;
            }
            if (portfolioOptionsMeta) {
                portfolioOptionsMeta.textContent = 'Loading…';
            }
            if (portfolioEmptyState) {
                portfolioEmptyState.classList.add('hidden');
            }
            lucide.createIcons();
        }

        async function initializePortfolioRail({ force = false } = {}) {
            if (portfolioAutoInitStarted && !force) {
                return;
            }
            portfolioAutoInitStarted = true;

            try {
                await loadPortfolioConfig();
            } catch (error) {
                console.warn('Portfolio config unavailable:', error);
            }

            try {
                const accountsResponse = await fetch('/api/portfolio/accounts');
                const accountsData = await accountsResponse.json();

                if (!accountsData.success || !Array.isArray(accountsData.accounts) || accountsData.accounts.length === 0) {
                    throw new Error('No accounts found. Please verify brokerage authentication.');
                }

                window.availableAccounts = accountsData.accounts;
                const accountIdKey = resolveDefaultAccountIdKey(accountsData.accounts);
                if (!accountIdKey) {
                    throw new Error('Default account not available.');
                }

                window.selectedAccountIdKey = accountIdKey;
                revealPortfolioRail();
                renderPortfolioLoadingState();
                setPortfolioStatus('Loading latest portfolio…', 'info');
                updateHeaderBalance(null);
                await loadAccountDetails(accountIdKey, { showLoading: false, reason: 'manual' });
                schedulePortfolioRefresh(accountIdKey);
                if (scanStatus) {
                    scanStatus.innerHTML = '<i data-lucide="check" class="w-4 h-4 text-green-600"></i> Portfolio synced';
                    lucide.createIcons();
                }
            } catch (error) {
                console.error('Portfolio auto-load error:', error);
                if (scanStatus) {
                    scanStatus.innerHTML = '<i data-lucide="x" class="w-4 h-4 text-red-600"></i> Portfolio error: ' + escapeHtml(error.message);
                    lucide.createIcons();
                }
                setPortfolioStatus('Portfolio load failed: ' + error.message, 'error');
                portfolioAutoInitStarted = false;
            }
        }

        async function loadAccountDetails(accountIdKey, { showLoading = true, reason = 'manual' } = {}) {
            if (!accountIdKey) {
                return false;
            }

            if (showLoading) {
                revealPortfolioRail();
                renderPortfolioLoadingState();
                setPortfolioStatus('Loading account data…', 'info');
            } else {
                setPortfolioStatus(reason === 'auto' ? 'Auto refresh in progress…' : 'Refreshing portfolio…', 'info');
            }

            try {
                let balanceData = null;
                try {
                    const balanceResponse = await fetch(`/api/portfolio/${accountIdKey}/balance`);
                    if (balanceResponse.ok) {
                        const balanceResult = await balanceResponse.json();
                        if (balanceResult.success) {
                            balanceData = balanceResult.balance;
                        }
                    }
                } catch (balanceErr) {
                    console.log('Balance API not available, continuing with basic info');
                }

                const portfolioResponse = await fetch(`/api/portfolio/${accountIdKey}`);
                const portfolioData = await portfolioResponse.json();

                if (!portfolioData.success) {
                    throw new Error(portfolioData.error || 'Failed to load portfolio');
                }

                revealPortfolioRail();
                displayPortfolio(portfolioData.portfolio, balanceData, { dayOrders: portfolioData.dayOrders || null });
                updateHeaderBalance(balanceData);
                lastPortfolioRefreshAt = Date.now();
                const label = reason === 'auto' ? 'Auto refreshed' : 'Updated';
                const suffix = reason === 'auto' ? '' : ' · auto refresh every 60s';
                setPortfolioStatus(`${label} at ${formatRefreshTimestamp(lastPortfolioRefreshAt)}${suffix}`, 'success');
                return true;
            } catch (error) {
                console.error('Account fetch error:', error);
                const accountDetails = window.availableAccounts?.find((acc) => acc.accountIdKey === accountIdKey);
                if (accountDetails) {
                    displayBasicAccountInfo(accountDetails);
                    updateHeaderBalance(null);
                    lastDayOrdersPayload = null;
                    renderDayPlPanel(null);
                } else {
                    if (accountSummary) {
                        accountSummary.innerHTML = `
                            <div class="col-span-2 text-center py-6">
                                <i data-lucide="alert-triangle" class="w-6 h-6 text-red-500 mx-auto mb-2"></i>
                                <div class="text-red-600 font-medium">Error Loading Account</div>
                                <div class="text-xs text-slate-500 mt-1">${escapeHtml(error.message)}</div>
                            </div>
                        `;
                    }
                }
                if (portfolioOptionsList) {
                    portfolioOptionsList.innerHTML = `
                        <div class="border border-red-200 bg-red-50 text-red-600 rounded-lg p-4 text-sm">
                            <div class="flex items-center gap-2">
                                <i data-lucide="alert-octagon" class="w-4 h-4"></i>
                                <span>Unable to load positions.</span>
                            </div>
                            <div class="text-xs text-red-500 mt-2">${escapeHtml(error.message)}</div>
                        </div>
                    `;
                }
                if (portfolioOptionsMeta) {
                    portfolioOptionsMeta.textContent = '';
                }
                if (portfolioEmptyState) {
                    portfolioEmptyState.classList.add('hidden');
                }
                lucide.createIcons();
                setPortfolioStatus(`Portfolio refresh failed: ${error.message}`, 'error');
                return false;
            }
        }

        if (refreshPortfolioBtn) {
            refreshPortfolioBtn.addEventListener('click', async () => {
                if (!window.selectedAccountIdKey) {
                    setPortfolioStatus('Attempting to load default account…', 'info');
                    await initializePortfolioRail({ force: true });
                    return;
                }
                await loadAccountDetails(window.selectedAccountIdKey, { showLoading: false, reason: 'manual' });
                schedulePortfolioRefresh(window.selectedAccountIdKey);
            });
        }

        window.addEventListener('beforeunload', () => {
            clearPortfolioRefreshTimer();
        });

        if (portfolioOptionsList) {
            portfolioOptionsList.addEventListener('click', async (event) => {
                const button = event.target.closest('button[data-action]');
                if (!button) {
                    return;
                }

                const action = button.dataset.action;
                if (action !== 'emergency-sell') {
                    return;
                }

                event.preventDefault();
                const accountIdKey = window.selectedAccountIdKey;
                if (!accountIdKey) {
                    alert('Load your default account before submitting an emergency sell.');
                    return;
                }

                const optionSymbol = button.dataset.optionSymbol || button.dataset.symbol;
                const quantity = Number(button.dataset.quantity);
                if (!optionSymbol) {
                    alert('Missing option symbol for this position.');
                    return;
                }
                if (!Number.isFinite(quantity) || quantity === 0) {
                    alert('Unable to determine position size for emergency sell.');
                    return;
                }

                const callPut = button.dataset.callPut || null;
                const strike = button.dataset.strike !== '' ? Number(button.dataset.strike) : null;
                const expiry = button.dataset.expiry || null;
                const positionId = button.dataset.positionId || null;
                const lastPrice = button.dataset.price !== '' ? Number(button.dataset.price) : null;

                const confirmationLines = [
                    `Account: ${accountIdKey}`,
                    `Option: ${optionSymbol}`,
                    `Quantity: ${quantity}`,
                    '',
                    'This will submit a market exit at the current market price immediately.',
                    'Existing stop or limit orders are not automatically cancelled.',
                    'Continue?',
                ];

                if (!window.confirm(confirmationLines.join('\n'))) {
                    return;
                }

                const payload = {
                    optionSymbol,
                    symbol: button.dataset.symbol || optionSymbol,
                    quantity,
                    positionId,
                    callPut,
                    strike: Number.isFinite(strike) ? strike : null,
                    expiry,
                    price: Number.isFinite(lastPrice) ? lastPrice : null,
                };

                const originalLabel = button.innerHTML;
                button.disabled = true;
                button.innerHTML = '<i data-lucide="loader" class="w-4 h-4 animate-spin"></i>';
                lucide.createIcons();

                try {
                    const response = await fetch(`/api/portfolio/${accountIdKey}/options/emergency-sell`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(payload),
                    });

                    let data = null;
                    try {
                        data = await response.json();
                    } catch (parseError) {
                        data = null;
                    }

                    if (!response.ok || !data?.success) {
                        const errorMessage = data?.error || `Broker rejected order (HTTP ${response.status})`;
                        throw new Error(errorMessage);
                    }

                    const messageLines = ['Emergency sell submitted successfully.'];
                    if (data.order?.orderId) {
                        messageLines.push(`Order ID: ${data.order.orderId}`);
                    }
                    if (data.order?.previewId) {
                        messageLines.push(`Preview ID: ${data.order.previewId}`);
                    }
                    if (Array.isArray(data.order?.messages) && data.order.messages.length) {
                        messageLines.push(`Broker notes: ${data.order.messages.join('; ')}`);
                    }

                    alert(messageLines.join('\n'));
                    await loadAccountDetails(accountIdKey, { showLoading: false, reason: 'manual' });
                } catch (err) {
                    alert(`Emergency sell failed: ${err.message}`);
                } finally {
                    button.disabled = false;
                    button.innerHTML = originalLabel;
                    lucide.createIcons();
                }
            });
        }

        // Display recommendations
        function displayRecommendations(recs, context = {}) {
            recommendations.innerHTML = '';

            const formatPrice = (value) => {
                if (Number.isFinite(value)) {
                    return Number(value).toFixed(2);
                }
                return '—';
            };

            const formatQuantity = (value) => {
                if (Number.isFinite(value)) {
                    return String(value);
                }
                return '—';
            };

            const formatPriceLabel = (value) => {
                const raw = formatPrice(value);
                return raw === '—' ? '—' : `$${raw}`;
            };

            const slugify = (value, fallback = 'item') => {
                if (!value) return fallback;
                return String(value)
                    .toLowerCase()
                    .replace(/[^a-z0-9]+/g, '-')
                    .replace(/^-+|-+$/g, '')
                    || fallback;
            };

            const formatSideLabel = (side, contract = '') => {
                const token = typeof side === 'string' ? side.trim().toUpperCase() : '';
                if (token === 'CALL' || token === 'PUT') {
                    return token;
                }
                const text = typeof contract === 'string' ? contract.toUpperCase() : '';
                if (text.includes(' CALL')) return 'CALL';
                if (text.includes(' PUT')) return 'PUT';
                return null;
            };

            const parseExpiryDate = (value) => {
                if (!value) return null;
                const text = String(value).trim();
                if (!text) return null;
                if (/^\d{4}-\d{2}-\d{2}$/.test(text)) {
                    const iso = new Date(`${text}T00:00:00Z`);
                    return Number.isNaN(iso.getTime()) ? null : iso;
                }
                const parsed = new Date(text);
                return Number.isNaN(parsed.getTime()) ? null : parsed;
            };

            const calculateHoldGuidance = (rec, fallbackExpiry) => {
                if (rec?.ai?.holdGuidance) {
                    return rec.ai.holdGuidance;
                }
                const expiryDate = parseExpiryDate(rec?.expiry || fallbackExpiry);
                if (!expiryDate) {
                    return 'Reassess daily; exit if momentum stalls to limit theta decay.';
                }
                const now = new Date();
                const diffMs = expiryDate.getTime() - now.getTime();
                const diffDays = Math.max(0, Math.round(diffMs / (1000 * 60 * 60 * 24)));
                if (diffDays <= 1) {
                    return 'Exit or roll today—expiration is imminent and theta risk is extreme.';
                }
                if (diffDays <= 3) {
                    return `Keep a tight leash; roll or exit within ${Math.max(1, diffDays - 1)} day(s) if momentum stays flat.`;
                }
                if (diffDays <= 7) {
                    return `Review after ${Math.max(1, diffDays - 2)} day(s); plan to roll early if price fails to move.`;
                }
                return `Target follow-through within ${Math.max(2, Math.round(diffDays / 2))} day(s); exit sooner if momentum breaks.`;
            };

            const formatConfidence = (rec) => {
                const raw = rec?.ai?.confidence;
                if (typeof raw === 'number') {
                    return `${Math.round(raw)}%`;
                }
                if (typeof raw === 'string' && raw.trim()) {
                    return raw.includes('%') ? raw.trim() : `${raw.trim()}%`;
                }
                if (Number.isFinite(rec?.ai?.strength)) {
                    return `${Math.round(rec.ai.strength)}%`;
                }
                return '—';
            };

            const createSparkline = (rec) => {
                const pointsSource = Array.isArray(rec?.sparkline)
                    ? rec.sparkline
                    : Array.isArray(rec?.sparklinePoints)
                        ? rec.sparklinePoints
                        : null;

                let series = null;
                if (pointsSource && pointsSource.length >= 2) {
                    series = pointsSource
                        .map((value) => Number(value))
                        .filter((value) => Number.isFinite(value));
                } else {
                    const fallback = [rec?.stop, rec?.entry, rec?.target]
                        .map((value) => Number(value))
                        .filter((value) => Number.isFinite(value));
                    series = fallback.length >= 2 ? fallback : null;
                }

                if (!Array.isArray(series) || series.length < 2) {
                    return null;
                }

                const width = 160;
                const height = 48;
                const min = Math.min(...series);
                const max = Math.max(...series);
                const range = max - min || 1;
                const step = width / (series.length - 1);
                const path = series
                    .map((value, index) => {
                        const x = (index * step).toFixed(1);
                        const y = (height - ((value - min) / range) * height).toFixed(1);
                        return `${index === 0 ? 'M' : 'L'}${x},${y}`;
                    })
                    .join(' ');

                const firstValue = series[0];
                const lastValue = series[series.length - 1];
                let trend = 'flat';
                let strokeColor = '#6B7280';
                if (lastValue > firstValue) {
                    trend = 'up';
                    strokeColor = '#10B981';
                } else if (lastValue < firstValue) {
                    trend = 'down';
                    strokeColor = '#EF4444';
                }

                const formattedValues = series.map((value) => Number.isFinite(value) ? Number(value.toFixed(2)) : value);

                return {
                    svg: `
                        <svg viewBox="0 0 ${width} ${height}" class="w-full h-12" preserveAspectRatio="none" role="img" aria-label="Price sparkline">
                            <path d="${path}" fill="none" stroke="${strokeColor}" stroke-width="2" stroke-linecap="round" />
                        </svg>
                    `,
                    values: formattedValues,
                    trend,
                    strokeColor,
                };
            };

            const formatSignalTag = (text) => {
                if (!text) return '';
                return text
                    .toString()
                    .trim()
                    .replace(/[_-]+/g, ' ')
                    .replace(/\b\w/g, (char) => char.toUpperCase());
            };

            const parseOccSymbol = (value) => {
                if (!value) return null;
                const cleaned = value.toString().toUpperCase().replace(/[^A-Z0-9]/g, '');
                const match = cleaned.match(/^([A-Z0-9]{1,6})(\d{6})([CP])(\d{8})$/);
                if (!match) return null;
                const [, underlying, yymmdd, cpFlag, strikeRaw] = match;
                const yy = Number(yymmdd.slice(0, 2));
                const mm = Number(yymmdd.slice(2, 4));
                const dd = Number(yymmdd.slice(4, 6));
                const year = yy >= 70 ? 1900 + yy : 2000 + yy;
                const month = String(mm).padStart(2, '0');
                const day = String(dd).padStart(2, '0');
                const strike = Number(strikeRaw) / 1000;
                return {
                    underlying: underlying.trim(),
                    expiry: `${year}-${month}-${day}`,
                    callPut: cpFlag === 'P' ? 'PUT' : 'CALL',
                    strike: Number.isFinite(strike) ? strike : null,
                };
            };

            const extractOptionMeta = (rec) => {
                const result = {
                    strike: Number.isFinite(rec?.strike) ? rec.strike : null,
                    expiry: rec?.expiry || null,
                };
                const possSymbol = rec?.optionSymbol
                    || rec?.option_details?.osiKey
                    || rec?.option_details?.symbol
                    || rec?.contract
                    || '';
                const occData = parseOccSymbol(possSymbol);
                if (occData) {
                    if (!result.expiry) {
                        result.expiry = occData.expiry;
                    }
                    if (!result.strike && Number.isFinite(occData.strike)) {
                        result.strike = occData.strike;
                    }
                }
                if ((!result.expiry || !result.strike) && typeof rec?.contract === 'string') {
                    const match = rec.contract.match(/(\d{4}-\d{2}-\d{2})/);
                    if (!result.expiry && match) {
                        result.expiry = match[1];
                    }
                    const strikeMatch = rec.contract.match(/\b(\d+(?:\.\d+)?)\s*(?:C|P)\b/i);
                    if (!result.strike && strikeMatch) {
                        result.strike = Number.parseFloat(strikeMatch[1]);
                    }
                }
                return result;
            };

            if (!Array.isArray(recs) || recs.length === 0) {
                lastRecommendationStats = null;
                updateRecommendationSummary(null);
                renderSidebarInsights();
                recommendations.innerHTML = `
                    <div class="bg-white border border-dashed border-slate-200 rounded-xl p-6 text-center text-slate-500">
                        <i data-lucide="alert-circle" class="w-10 h-10 text-slate-300 mx-auto mb-3"></i>
                        <div class="text-sm font-semibold">No active trade ideas</div>
                        <div class="text-xs text-slate-400">Run a scan to surface the latest AI suggestions.</div>
                    </div>
                `;
                lucide.createIcons();
                return;
            }

            const providerSet = new Set();
            const signalFrequency = new Map();
            const riskFlagSymbols = new Set();
            let totalRiskFlags = 0;
            const decisionCounts = { approve: 0, caution: 0, reject: 0, unknown: 0 };
            const callPutCounts = { call: 0, put: 0 };

            recs.forEach((rec) => {
                const decisionKey = normalizeDecision(rec.ai?.decision);
                decisionCounts[decisionKey] = (decisionCounts[decisionKey] || 0) + 1;

                const providerKey = String(rec.ai?.provider || rec.provider || 'AI').toUpperCase();
                providerSet.add(providerKey);

                if (Array.isArray(rec.ai?.riskFlags) && rec.ai.riskFlags.length) {
                    riskFlagSymbols.add(String(rec.symbol || '').toUpperCase());
                    totalRiskFlags += rec.ai.riskFlags.filter(Boolean).length;
                }

                let sideToken = String(rec.side || '').toLowerCase();
                if (!sideToken && typeof rec.contract === 'string') {
                    const contractUpper = rec.contract.toUpperCase();
                    if (contractUpper.includes('CALL')) {
                        sideToken = 'call';
                    } else if (contractUpper.includes('PUT')) {
                        sideToken = 'put';
                    }
                }
                if (sideToken === 'call' || sideToken === 'put') {
                    callPutCounts[sideToken] = (callPutCounts[sideToken] || 0) + 1;
                }

                if (Array.isArray(rec.signals)) {
                    rec.signals.forEach((sig) => {
                        if (!sig) return;
                        const trimmed = sig.toString().trim();
                        if (!trimmed) return;
                        signalFrequency.set(trimmed, (signalFrequency.get(trimmed) || 0) + 1);
                    });
                }
            });

            const groupsMap = new Map();
            recs.forEach((rec, idx) => {
                const symbol = (rec.symbol || `UNKNOWN_${idx}`).toUpperCase();
                if (!groupsMap.has(symbol)) {
                    groupsMap.set(symbol, []);
                }
                groupsMap.get(symbol).push(rec);
            });

            const decisionRank = { approve: 3, caution: 2, reject: 1, unknown: 0 };

            const grouped = Array.from(groupsMap.entries()).map(([symbol, items]) => {
                const bestRec = items.reduce((best, item) => {
                    const itemStrength = Number.isFinite(item.ai?.strength) ? item.ai.strength : -Infinity;
                    const bestStrength = Number.isFinite(best.ai?.strength) ? best.ai.strength : -Infinity;
                    if (itemStrength > bestStrength) {
                        return item;
                    }
                    if (itemStrength === bestStrength) {
                        const itemRank = decisionRank[normalizeDecision(item.ai?.decision)] || 0;
                        const bestRank = decisionRank[normalizeDecision(best.ai?.decision)] || 0;
                        if (itemRank > bestRank) {
                            return item;
                        }
                    }
                    return best;
                }, items[0]);
                return { symbol, items, bestRec };
            });

            grouped.sort((a, b) => {
                const aStrength = Number.isFinite(a.bestRec?.ai?.strength) ? a.bestRec.ai.strength : -Infinity;
                const bStrength = Number.isFinite(b.bestRec?.ai?.strength) ? b.bestRec.ai.strength : -Infinity;
                if (bStrength !== aStrength) {
                    return bStrength - aStrength;
                }
                return a.symbol.localeCompare(b.symbol);
            });

            const topSignals = Array.from(signalFrequency.entries())
                .sort((a, b) => b[1] - a[1])
                .slice(0, 3)
                .map(([name, count]) => ({ name, count }));

            lastRecommendationStats = {
                totalSymbols: grouped.length,
                totalIdeas: recs.length,
                providerCount: providerSet.size,
                decisionCounts,
                riskFlagSymbols: Array.from(riskFlagSymbols).filter(Boolean),
                totalRiskFlags,
                topSignals,
                callPutCounts: {
                    call: callPutCounts.call || 0,
                    put: callPutCounts.put || 0,
                },
            };

            updateRecommendationSummary(lastRecommendationStats);
            renderSidebarInsights();

            const parseConfidenceValue = (value) => {
                if (value == null) return null;
                let numeric = value;
                if (typeof numeric === 'string') {
                    const stripped = numeric.replace(/%/g, '').trim();
                    if (!stripped) return null;
                    numeric = Number(stripped);
                }
                if (!Number.isFinite(numeric)) return null;
                if (numeric <= 1) {
                    numeric *= 100;
                }
                return Math.max(0, Math.min(100, Number(numeric.toFixed(1))));
            };

            const formatConfidencePercent = (value) => {
                if (!Number.isFinite(value)) return '—';
                return `${value.toFixed(0)}%`;
            };

            const verdictBadgeMeta = {
                approve: { bg: '#16A34A', text: '#FFFFFF' },
                caution: { bg: '#F59E0B', text: '#111827' },
                reject: { bg: '#DC2626', text: '#FFFFFF' },
                unknown: { bg: '#6B7280', text: '#FFFFFF' },
            };

            const getVerdictBadgeStyle = (verdictKey) => {
                const key = String(verdictKey || '').toLowerCase();
                return verdictBadgeMeta[key] || verdictBadgeMeta.unknown;
            };

            const getConfidenceToneColor = (value) => {
                if (!Number.isFinite(value)) {
                    return '#6B7280';
                }
                if (value >= 75) {
                    return '#16A34A';
                }
                if (value >= 50) {
                    return '#F59E0B';
                }
                return '#DC2626';
            };

            const getConfidencePillStyle = (value) => {
                const base = { bg: '#E5E7EB', text: '#374151' };
                if (!Number.isFinite(value)) {
                    return base;
                }
                if (value >= 75) {
                    return { bg: '#16A34A', text: '#FFFFFF' };
                }
                if (value >= 50) {
                    return { bg: '#F59E0B', text: '#111827' };
                }
                return { bg: '#DC2626', text: '#FFFFFF' };
            };

            const signalConditionLookup = new Map([
                ['macd bullish', 'MACD histogram stays positive with signal line above zero'],
                ['high volume', 'Volume ≥ 1.3× 20-period average on confirmation candle'],
                ['support bounce', 'Price prints higher low off intraday support before entry'],
                ['near resistance', 'Break and hold above immediate resistance on strong tape'],
                ['vwap hold', 'Price holds above VWAP on 5m close prior to entry'],
                ['ema support', 'Maintain closes above EMA support zone through entry trigger'],
            ]);

            const deriveBuyConditions = (signals) => {
                const conditions = [];
                const seen = new Set();
                signals.forEach((label) => {
                    const key = label.toLowerCase();
                    if (signalConditionLookup.has(key) && !seen.has(key)) {
                        seen.add(key);
                        conditions.push(signalConditionLookup.get(key));
                    }
                });
                if (!conditions.length) {
                    conditions.push('Candle close above VWAP with expanding volume confirmation');
                }
                return conditions;
            };

            const deriveExitConditions = ({ stop, target, expiryLabel, tradePlan, holdGuidance }) => {
                const exits = [];
                if (Number.isFinite(stop)) {
                    exits.push(`Stop loss trigger at $${Number(stop).toFixed(2)} or loss of VWAP on closing basis`);
                } else {
                    exits.push('Honor hard stop per risk plan or exit if VWAP fails');
                }
                if (expiryLabel && expiryLabel !== '—') {
                    exits.push(`Time stop: exit by ${expiryLabel} if target not achieved, respect ${holdGuidance}`);
                } else {
                    exits.push(`Time stop: exit before final trading hour if target not achieved (${holdGuidance})`);
                }
                if (Array.isArray(tradePlan?.iterations) && tradePlan.iterations.length) {
                    const steps = tradePlan.iterations
                        .map((step) => {
                            const targetLabel = step.target != null ? `$${Number(step.target).toFixed(2)}` : 'strength pop';
                            return `${step.sellQty} @ ${targetLabel}`;
                        })
                        .join(', ');
                    exits.push(`Scaling plan: trim ${steps}`);
                } else if (Number.isFinite(target)) {
                    exits.push(`Scaling plan: take partials near $${Number(target).toFixed(2)} and trail remainder tightly`);
                } else {
                    exits.push('Scaling plan: scale out into local resistance levels while trailing stop-up');
                }
                return exits;
            };

            grouped.forEach(({ symbol, items, bestRec }) => {
                const focusRec = bestRec || items[0];
                const baseDecision = normalizeDecision(focusRec?.ai?.decision);
                const optionMeta = extractOptionMeta(focusRec);
                const strike = optionMeta.strike;
                const expiry = optionMeta.expiry;
                const strikeLabel = Number.isFinite(strike) ? `$${strike.toFixed(strike % 1 === 0 ? 0 : 2)}` : '—';
                const sideLabel = formatSideLabel(focusRec.side, focusRec.contract);
                const strikeDescriptor = sideLabel ? `${strikeLabel} ${sideLabel}` : strikeLabel;
                const expiryLabel = expiry || '—';
                const resolveUnderlyingPrice = () => {
                    const candidates = [
                        focusRec?.price,
                        focusRec?.underlyingPrice,
                        focusRec?.lastPrice,
                        focusRec?.underlying?.last,
                    ];
                    for (const value of candidates) {
                        if (Number.isFinite(value)) {
                            return Number(value);
                        }
                    }
                    return null;
                };
                const underlyingPrice = resolveUnderlyingPrice();
                const underlyingPriceLabel = underlyingPrice != null ? `$${underlyingPrice.toFixed(2)}` : 'N/A';

                const signalSet = new Set();
                items.forEach((item) => {
                    (item.signals || []).forEach((sig) => signalSet.add(formatSignalTag(sig)));
                });
                const signalTags = Array.from(signalSet)
                    .filter(Boolean)
                    .map((label) => label.replace(/\s+/g, ' ').trim());

                const providerDetails = items
                    .slice()
                    .sort((a, b) => {
                        const providerA = String(a.ai?.provider || a.provider || '').toLowerCase();
                        const providerB = String(b.ai?.provider || b.provider || '').toLowerCase();
                        return providerA.localeCompare(providerB);
                    })
                    .map((rec) => {
                        const providerName = String(rec.ai?.provider || rec.provider || 'AI');
                        const confidenceFromAI = rec.ai?.confidence ?? rec.ai?.strength ?? null;
                        const confidence = parseConfidenceValue(confidenceFromAI);
                        const entry = Number.isFinite(rec.entry) ? Number(rec.entry) : null;
                        const stop = Number.isFinite(rec.stop) ? Number(rec.stop) : null;
                        const target = Number.isFinite(rec.target) ? Number(rec.target) : null;
                        const notes = [];
                        if (rec.ai?.notes) {
                            notes.push(rec.ai.notes);
                        }
                        if (Array.isArray(rec.ai?.riskFlags) && rec.ai.riskFlags.length) {
                            rec.ai.riskFlags.filter(Boolean).forEach((flag) => notes.push(flag));
                        }
                        if (rec.ai?.adjustments && typeof rec.ai.adjustments === 'object') {
                            const adj = Object.entries(rec.ai.adjustments)
                                .filter(([, value]) => value != null)
                                .map(([key, value]) => `${key}: ${value}`);
                            if (adj.length) {
                                notes.push(`Adjustments -> ${adj.join(', ')}`);
                            }
                        }
                        const noteLines = notes.length ? notes : ['No additional commentary'];
                        return {
                            provider: providerName,
                            confidence,
                            entry,
                            stop,
                            target,
                            noteLines,
                        };
                    });

                const confidenceValues = providerDetails
                    .map((detail) => detail.confidence)
                    .filter((value) => Number.isFinite(value));
                const confluenceScore = confidenceValues.length
                    ? confidenceValues.reduce((sum, value) => sum + value, 0) / confidenceValues.length
                    : null;
                const confluenceScoreLabel = Number.isFinite(confluenceScore) ? `${confluenceScore.toFixed(1)}%` : 'N/A';

                const confidenceSpread = confidenceValues.length >= 2
                    ? Math.max(...confidenceValues) - Math.min(...confidenceValues)
                    : 0;
                const hasDisagreement = confidenceSpread > 25;

                const entryPrice = Number.isFinite(focusRec.entry) ? Number(focusRec.entry) : null;
                const stopPrice = Number.isFinite(focusRec.stop) ? Number(focusRec.stop) : null;
                const targetPrice = Number.isFinite(focusRec.target) ? Number(focusRec.target) : null;
                let rewardToRisk = null;
                if (entryPrice != null && stopPrice != null && targetPrice != null) {
                    const risk = entryPrice - stopPrice;
                    const reward = targetPrice - entryPrice;
                    if (risk > 0 && reward > 0) {
                        rewardToRisk = reward / risk;
                    }
                }

                const spreadPct = Number.isFinite(focusRec?.spread_pct)
                    ? Number(focusRec.spread_pct)
                    : Number.isFinite(focusRec?.option_details?.spread_pct)
                        ? Number(focusRec.option_details.spread_pct)
                        : Number.isFinite(focusRec?.liquidity?.spread_pct)
                            ? Number(focusRec.liquidity.spread_pct)
                            : null;
                const wideSpreadRisk = Number.isFinite(spreadPct) && spreadPct > 5;

                let verdict = baseDecision;
                if (rewardToRisk != null && rewardToRisk < 2.5) {
                    verdict = 'reject';
                } else if (Number.isFinite(confluenceScore) && confluenceScore < 70) {
                    verdict = 'caution';
                }
                if (!verdict || verdict === 'unknown') {
                    verdict = Number.isFinite(confluenceScore) && confluenceScore >= 70 ? 'approve' : 'caution';
                }

                const holdGuidance = calculateHoldGuidance(focusRec, expiryLabel);
                const buyConditions = deriveBuyConditions(Array.from(signalSet));
                const tradePlanPayload = focusRec.tradePlan
                    ? focusRec.tradePlan
                    : (Array.isArray(focusRec.scalingPlan) ? { iterations: focusRec.scalingPlan } : null);
                const exitConditions = deriveExitConditions({
                    stop: stopPrice,
                    target: targetPrice,
                    expiryLabel,
                    tradePlan: tradePlanPayload,
                    holdGuidance,
                });

                const sparklineData = createSparkline(focusRec);

                const providerRowsHtml = providerDetails
                    .map((detail, index) => {
                        const entryCell = detail.entry != null ? detail.entry.toFixed(2) : '—';
                        const stopCell = detail.stop != null ? detail.stop.toFixed(2) : '—';
                        const targetCell = detail.target != null ? detail.target.toFixed(2) : '—';
                        const rowStyle = index % 2 === 1 ? ' style="background-color:#F9FAFB;"' : '';
                        const pillStyle = getConfidencePillStyle(detail.confidence);
                        const confidenceLabel = escapeHtml(formatConfidencePercent(detail.confidence));
                        return `
                            <tr${rowStyle} class="text-sm text-[#111827]">
                                <td class="px-4 py-2 font-semibold">${escapeHtml(detail.provider)}</td>
                                <td class="px-4 py-2 text-center">
                                    <span class="inline-flex items-center px-2.5 py-0.5 rounded-full text-xs font-semibold" style="background-color:${pillStyle.bg};color:${pillStyle.text};min-width:3.75rem;justify-content:center;">${confidenceLabel}</span>
                                </td>
                                <td class="px-4 py-2 text-right text-[#6B7280]" style="font-variant-numeric: tabular-nums;font-feature-settings:'tnum';">${escapeHtml(entryCell)}</td>
                                <td class="px-4 py-2 text-right text-[#6B7280]" style="font-variant-numeric: tabular-nums;font-feature-settings:'tnum';">${escapeHtml(stopCell)}</td>
                                <td class="px-4 py-2 text-right text-[#6B7280]" style="font-variant-numeric: tabular-nums;font-feature-settings:'tnum';">${escapeHtml(targetCell)}</td>
                            </tr>
                        `;
                    })
                    .join('');

                const providerInsightsHtml = providerDetails
                    .map((detail) => {
                        const noteItems = detail.noteLines.length ? detail.noteLines : ['No additional commentary'];
                        const bullets = noteItems
                            .map((line) => `<li class="flex gap-2 text-sm text-[#6B7280]" style="line-height:1.2;"><span class="text-[#6B7280]">•</span><span>${escapeHtml(line)}</span></li>`)
                            .join('');
                        return `
                            <div class="space-y-2">
                                <div class="text-sm font-semibold text-[#111827]">${escapeHtml(detail.provider)}</div>
                                <ul class="space-y-0.5 ml-2">${bullets}</ul>
                            </div>
                        `;
                    })
                    .join('<div class="h-px bg-[#E5E7EB]"></div>');

                let decisionSummary = 'Trade marked caution until confluence or risk profile improves.';
                if (verdict === 'approve') {
                    decisionSummary = 'Trade approved because confluence meets thresholds and reward-to-risk is acceptable.';
                } else if (verdict === 'reject') {
                    decisionSummary = 'Trade rejected because reward-to-risk fails to clear minimum threshold.';
                }
                if (wideSpreadRisk) {
                    decisionSummary += ' Wide spread risk requires careful fills.';
                } else if (hasDisagreement) {
                    decisionSummary += ' Provider confidence spread indicates mixed conviction.';
                }

                const decisionTldr = (() => {
                    const rawTldr = focusRec.ai?.tldr;
                    if (typeof rawTldr === 'string' && rawTldr.trim()) {
                        return rawTldr.trim();
                    }
                    const aiSummary = focusRec.ai?.summary;
                    if (typeof aiSummary === 'string' && aiSummary.trim()) {
                        const sentence = aiSummary.trim().split(/(?<=[.!?])\s+/)[0];
                        if (sentence) return sentence;
                    }
                    if (buyConditions.length) {
                        return buyConditions[0];
                    }
                    return decisionSummary;
                })();

                const rulesLines = [
                    'If CONFLUENCE_SCORE < 70 → VERDICT = CAUTION',
                    'If R/R < 2.5 → VERDICT = REJECT',
                ];
                if (hasDisagreement) {
                    rulesLines.push('Provider disagreement flagged because confidence spread exceeds 25%');
                }
                if (wideSpreadRisk) {
                    rulesLines.push('Wide spread risk flagged because bid/ask spread exceeds 5%');
                }

                const buyListHtml = buyConditions
                    .map((item) => `<li class="flex gap-2" style="line-height:1.2;"><span class="text-[#6B7280]">•</span><span>${escapeHtml(item)}</span></li>`)
                    .join('');

                const exitListHtml = exitConditions
                    .map((item) => `<li class="flex gap-2" style="line-height:1.2;"><span class="text-[#6B7280]">•</span><span>${escapeHtml(item)}</span></li>`)
                    .join('');

                const scalingPlanItems = (() => {
                    if (Array.isArray(tradePlanPayload?.iterations) && tradePlanPayload.iterations.length) {
                        return tradePlanPayload.iterations.map((step, index) => {
                            const qtyLabel = step.sellQty != null ? String(step.sellQty) : `Step ${index + 1}`;
                            const targetLabel = step.target != null ? `$${Number(step.target).toFixed(2)}` : 'Momentum strength';
                            return `${qtyLabel} at ${targetLabel}`;
                        });
                    }
                    if (Number.isFinite(targetPrice)) {
                        return [
                            `Trim partial near $${targetPrice.toFixed(2)}`,
                            'Trail remainder once first target fills',
                        ];
                    }
                    return ['No scaling instructions provided'];
                })();

                const scalingListHtml = scalingPlanItems
                    .map((item) => `<li class="flex gap-2" style="line-height:1.2;"><span class="text-[#6B7280]">•</span><span>${escapeHtml(item)}</span></li>`)
                    .join('');

                const rulesListHtml = rulesLines
                    .map((item) => `<li class="flex gap-2 text-sm" style="line-height:1.2;"><span class="text-[#6B7280]">•</span><span>${escapeHtml(item)}</span></li>`)
                    .join('');

                const badgeStyle = getVerdictBadgeStyle(verdict);
                const confluenceColor = getConfidenceToneColor(confluenceScore);
                const sparklineTrendLabel = sparklineData
                    ? sparklineData.trend === 'up'
                        ? 'Uptrend'
                        : sparklineData.trend === 'down'
                            ? 'Downtrend'
                            : 'Flat'
                    : 'Unavailable';
                const sparklineVisual = sparklineData
                    ? `<div class="flex flex-col gap-2"><div class="w-full">${sparklineData.svg}</div><div class="text-xs text-[#6B7280]">Data points: ${sparklineData.values.map((value) => Number(value).toFixed(2)).join(', ')}</div></div>`
                    : '<div class="text-sm text-[#6B7280]">Insufficient data for sparkline.</div>';

                const tagChipsHtml = signalTags.length
                    ? signalTags
                        .map((tag) => `<span class="tag-chip inline-flex items-center px-2.5 py-1 rounded-full text-xs font-medium">${escapeHtml(tag)}</span>`)
                        .join('')
                    : '<span class="tag-chip inline-flex items-center px-2.5 py-1 rounded-full text-xs font-medium">No signals</span>';
                const ideaId = buildIdeaId({ symbol, strike, expiry, side: focusRec.side });
                const isTrackedIdea = trackedIdeas.some((idea) => idea.id === ideaId);
                const rawOptionSymbol = focusRec.optionSymbol
                    || focusRec.option_details?.osiKey
                    || focusRec.option_details?.symbol
                    || focusRec.contract
                    || '';
                const optionSide = normalizeOptionSide(focusRec.side, rawOptionSymbol || '');
                const optionSymbolDataset = rawOptionSymbol;
                const hasContractMeta = Boolean(optionSide && strike != null && expiry && entryPrice != null);

                recommendations.innerHTML += `
                    <article class="bg-white border border-[#E5E7EB] shadow-sm rounded-3xl p-6 space-y-6 text-[#111827]">
                        <header class="flex flex-wrap items-start justify-between gap-4">
                            <div class="space-y-3">
                                <div class="text-xs uppercase tracking-[0.3em] text-[#6B7280]">Ticker</div>
                                <div class="text-3xl font-semibold">${escapeHtml(symbol)}</div>
                                <div class="flex flex-wrap gap-4 text-sm text-[#6B7280]">
                                    <span><span class="uppercase tracking-wide text-xs text-[#6B7280]">Strike&nbsp;</span><strong class="text-[#111827]">${escapeHtml(strikeDescriptor)}</strong></span>
                                    <span><span class="uppercase tracking-wide text-xs text-[#6B7280]">Expiry&nbsp;</span><strong class="text-[#111827]">${escapeHtml(expiryLabel)}</strong></span>
                                    <span><span class="uppercase tracking-wide text-xs text-[#6B7280]">Current&nbsp;Price&nbsp;</span><strong class="text-[#111827]">${escapeHtml(underlyingPriceLabel)}</strong></span>
                                </div>
                            </div>
                            <div class="flex flex-col items-end gap-2">
                                <span class="inline-flex items-center px-3 py-1.5 rounded-full text-xs font-semibold shadow-sm" style="background-color:${badgeStyle.bg};color:${badgeStyle.text};">${escapeHtml(verdict.toUpperCase())}</span>
                                <div class="text-xs font-medium text-[#6B7280]">Confluence Score:&nbsp;<span style="color:${confluenceColor};">${escapeHtml(confluenceScoreLabel)}</span></div>
                                <p class="text-xs text-[#6B7280] max-w-[220px] text-right" style="line-height:1.3;">${escapeHtml(decisionTldr)}</p>
                                <button
                                    type="button"
                                    class="track-btn inline-flex items-center justify-center text-xs font-semibold border border-slate-200 rounded-lg px-3 py-1.5 w-full sm:w-auto"
                                    style="min-width:7.5rem;"
                                    data-track-idea="true"
                                    data-idea-id="${escapeHtml(ideaId)}"
                                    data-symbol="${escapeHtml(symbol)}"
                                    data-strike="${strike != null ? strike : ''}"
                                    data-expiry="${escapeHtml(expiry || '')}"
                                    data-side="${escapeHtml(focusRec.side || '')}"
                                    data-decision="${escapeHtml(verdict)}"
                                    data-entry="${entryPrice != null ? entryPrice : ''}"
                                    data-stop="${stopPrice != null ? stopPrice : ''}"
                                    data-target="${targetPrice != null ? targetPrice : ''}"
                                    data-summary="${escapeHtml(decisionTldr)}"
                                    aria-pressed="${isTrackedIdea ? 'true' : 'false'}"
                                    data-track-state="${isTrackedIdea ? 'tracked' : 'idle'}"
                                >
                                    ${isTrackedIdea ? 'Update Tile' : 'Track Idea'}
                                </button>
                                ${hasContractMeta ? `
                                <button
                                    type="button"
                                    class="inline-flex items-center justify-center text-xs font-semibold border border-emerald-200 text-emerald-700 rounded-lg px-3 py-1.5 bg-emerald-50 hover:bg-emerald-100 transition"
                                    style="min-width:9rem;"
                                    data-market-buy="true"
                                    data-symbol="${escapeHtml(symbol)}"
                                    data-option-symbol="${escapeHtml(optionSymbolDataset)}"
                                    data-side="${escapeHtml(optionSide || '')}"
                                    data-strike="${strike != null ? strike : ''}"
                                    data-expiry="${escapeHtml(expiry || '')}"
                                    data-price="${entryPrice != null ? entryPrice : ''}"
                                    data-quantity="${focusRec.qty != null ? focusRec.qty : ''}"
                                >
                                    Buy w/ Cash
                                </button>` : `
                                <span class="text-[11px] text-slate-400 text-right">Contract details missing; update scan to enable buy.</span>`}
                            </div>
                        </header>

                        <div class="flex flex-wrap gap-2">${tagChipsHtml}</div>

                        <div class="h-px bg-[#E5E7EB]"></div>

                        <section class="space-y-3">
                            <h3 class="text-sm font-semibold uppercase tracking-wide text-[#111827]">Comparison Grid</h3>
                            <div class="overflow-hidden border border-[#E5E7EB] rounded-2xl">
                                <table class="w-full text-sm text-[#111827] font-tabular-nums">
                                    <thead class="bg-white text-xs uppercase tracking-wide" style="color:#64748B;">
                                        <tr>
                                            <th class="px-4 py-2 text-left">Provider</th>
                                            <th class="px-4 py-2 text-center">Confidence</th>
                                            <th class="px-4 py-2 text-right">Entry</th>
                                            <th class="px-4 py-2 text-right">Stop</th>
                                            <th class="px-4 py-2 text-right">Target</th>
                                        </tr>
                                    </thead>
                                    <tbody>${providerRowsHtml}</tbody>
                                </table>
                            </div>
                        </section>

                        <div class="h-px bg-[#E5E7EB]"></div>

                        <section class="space-y-3">
                            <h3 class="flex items-center gap-2 text-sm font-semibold text-[#111827] pb-2 border-b border-[#E5E7EB]"><span class="text-base">🧠</span>AI Insights</h3>
                            <div class="space-y-4">${providerInsightsHtml}</div>
                        </section>

                        <div class="h-px bg-[#E5E7EB]"></div>

                        <section class="space-y-2">
                            <h3 class="text-sm font-semibold text-[#111827] pb-2 border-b border-[#E5E7EB]">Decision Summary</h3>
                            <p class="text-sm text-[#6B7280] leading-relaxed">${escapeHtml(decisionSummary)}</p>
                        </section>

                        <div class="h-px bg-[#E5E7EB]"></div>

                        <section class="space-y-3">
                            <h3 class="flex items-center gap-2 text-sm font-semibold text-[#111827] pb-2 border-b border-[#E5E7EB]"><span class="text-base">✅</span>Buy Conditions</h3>
                            <ul class="space-y-0.5 text-sm text-[#111827]">${buyListHtml}</ul>
                        </section>

                        <section class="space-y-3">
                            <h3 class="flex items-center gap-2 text-sm font-semibold text-[#111827] pb-2 border-b border-[#E5E7EB]"><span class="text-base">❌</span>Exit Conditions</h3>
                            <ul class="space-y-0.5 text-sm text-[#111827]">${exitListHtml}</ul>
                        </section>

                        <section class="space-y-3">
                            <h3 class="flex items-center gap-2 text-sm font-semibold text-[#111827] pb-2 border-b border-[#E5E7EB]"><span class="text-base">📈</span>Scaling Plan</h3>
                            <ul class="space-y-0.5 text-sm text-[#111827]">${scalingListHtml}</ul>
                        </section>

                        <section class="space-y-3">
                            <h3 class="text-sm font-semibold text-[#111827] pb-2 border-b border-[#E5E7EB]">Rules Enforced</h3>
                            <ul class="space-y-0.5 text-sm text-[#111827]">${rulesListHtml}</ul>
                        </section>

                        <div class="h-px bg-[#E5E7EB]"></div>

                        <section class="space-y-2">
                            <div class="flex items-center justify-between text-sm font-semibold text-[#111827]">
                                <span>Sparkline Trend</span>
                                <span class="text-xs uppercase tracking-wide" style="color:${sparklineData ? sparklineData.strokeColor : '#6B7280'};">${sparklineTrendLabel}</span>
                            </div>
                            <div class="rounded-2xl border border-[#E5E7EB] bg-[#F9FAFB] p-4">
                                ${sparklineVisual}
                            </div>
                        </section>
                    </article>
                `;
            });

            lucide.createIcons();
            syncTrackedIdeaButtons();
        }

        // Display portfolio
        function displayPortfolio(portfolio, balanceData = null, { skipStore = false, dayOrders = null } = {}) {
            if (!portfolio) {
                return;
            }

        if (!skipStore) {
            lastPortfolioPayload = portfolio;
            lastPortfolioBalance = balanceData || null;
            lastDayOrdersPayload = dayOrders || null;
        }

        updateDayPlPanelData(portfolio, dayOrders || lastDayOrdersPayload);

            revealPortfolioRail();

            const accountIdKey = portfolio?.account?.accountIdKey || window.selectedAccountIdKey;
            const accountDetails = window.availableAccounts?.find((acc) => acc.accountIdKey === accountIdKey);
            const primaryAccountId = accountDetails?.accountId || balanceData?.accountId || portfolio.account?.accountId || 'N/A';
            const summaryItems = [];

            if (balanceData) {
                const availableCash = Number(balanceData.cashAvailableForInvestment ?? balanceData.moneyMktBalance ?? balanceData.cashBalance ?? balanceData.cash ?? 0);
                const withdrawCash = Number(balanceData.cashAvailableForWithdrawal ?? balanceData.cashAvailableToWithdraw ?? balanceData.fundsForWithdrawal ?? availableCash);
                const totalValue = Number(balanceData.totalAccountValue ?? 0);
                const buyingPower = Number(balanceData.cashBuyingPower ?? balanceData.marginBuyingPower ?? 0);
                summaryItems.push(
                    {
                        label: 'Account ID',
                        value: getAccountIdString(balanceData.accountId || primaryAccountId),
                        accent: 'text-blue-600',
                    },
                    {
                        label: 'Available Cash',
                        value: getCurrencyString(availableCash),
                        accent: 'text-emerald-600',
                    },
                    {
                        label: 'Cash To Withdraw',
                        value: getCurrencyString(withdrawCash),
                        accent: 'text-teal-600',
                    },
                    {
                        label: 'Total Value',
                        value: getCurrencyString(totalValue),
                        accent: 'text-purple-600',
                    },
                    {
                        label: 'Buying Power',
                        value: getCurrencyString(buyingPower),
                        accent: 'text-amber-600',
                    }
                );
            } else {
                summaryItems.push(
                    {
                        label: 'Account ID',
                        value: getAccountIdString(primaryAccountId),
                        accent: 'text-blue-600',
                    },
                    {
                        label: 'Account Type',
                        value: accountDetails?.accountType || 'INDIVIDUAL',
                        accent: 'text-emerald-600',
                    },
                    {
                        label: 'Account Mode',
                        value: accountDetails?.accountMode || 'CASH',
                        accent: 'text-purple-600',
                    },
                    {
                        label: 'Status',
                        value: accountDetails?.accountStatus || 'ACTIVE',
                        accent: 'text-amber-600',
                    }
                );
            }

            if (accountSummary) {
                accountSummary.innerHTML = summaryItems
                    .map((item) => `
                        <div class="bg-slate-50 border border-slate-100 rounded-lg p-3">
                            <div class="text-[11px] uppercase tracking-wide text-slate-400">${escapeHtml(item.label)}</div>
                            <div class="text-base font-semibold ${item.accent}">${escapeHtml(String(item.value))}</div>
                        </div>
                    `)
                    .join('');
            }

            const positions = Array.isArray(portfolio.positions) ? portfolio.positions : [];
            const optionPositions = positions.filter((position) => {
                if (!position) {
                    return false;
                }
                const desc = position.symbolDescription ? position.symbolDescription.toLowerCase() : '';
                const sym = position.symbol || '';
                return (
                    desc.includes('call') ||
                    desc.includes('put') ||
                    desc.includes('option') ||
                    sym.includes(' ') ||
                    /\d{6}[CP]\d+/.test(sym)
                );
            });

            const hasOptions = optionPositions.length > 0;
            const totalMarketValue = optionPositions.reduce((sum, pos) => {
                const value = Number(pos.marketValue);
                return Number.isFinite(value) ? sum + value : sum;
            }, 0);

            if (portfolioOptionsMeta) {
                if (hasOptions) {
                    portfolioOptionsMeta.textContent = `${optionPositions.length} position${optionPositions.length === 1 ? '' : 's'} · ${getCurrencyString(totalMarketValue)}`;
                } else {
                    portfolioOptionsMeta.textContent = '';
                }
            }

            if (portfolioOptionsList) {
                if (hasOptions) {
                    const renderValue = (value, { currency = false, fallback = 'N/A', decimals = 2 } = {}) => {
                        const numeric = Number(value);
                        if (!Number.isFinite(numeric)) {
                            return fallback;
                        }
                        if (currency) {
                            return getCurrencyString(numeric);
                        }
                        return numeric.toFixed(decimals);
                    };

                    const renderPercent = (value) => {
                        const numeric = Number(value);
                        if (!Number.isFinite(numeric)) {
                            return 'N/A';
                        }
                        return `${numeric.toFixed(2)}%`;
                    };

                    const formatCallPut = (value, fallbackSymbol) => {
                        const token = String(value || '').toUpperCase();
                        if (token === 'CALL' || token === 'PUT') {
                            return token;
                        }
                        const upperSym = String(fallbackSymbol || '').toUpperCase();
                        if (upperSym.includes(' CALL')) return 'CALL';
                        if (upperSym.includes(' PUT')) return 'PUT';
                        return 'OPTION';
                    };

                    const optionCards = optionPositions
                        .map((position) => {
                            const optionSymbolRaw = position.osiKey
                                || position.optionSymbol
                                || position.symbol
                                || '';
                            const underlyingRaw = position.Product?.symbol
                                || position.underlyingSymbol
                                || (optionSymbolRaw ? optionSymbolRaw.replace(/[-\s]+.*$/, '').trim() : '');
                            const symbol = escapeHtml(underlyingRaw || optionSymbolRaw || position.symbolDescription || 'N/A');
                            const description = escapeHtml(position.symbolDescription || '');
                            const quantity = Number.isFinite(Number(position.quantity)) ? Number(position.quantity) : null;
                            const avgPrice = position.pricePaid || position.averagePrice;
                            const pnl = Number(position.unrealizedGainLoss);
                            const pnlClass = Number.isFinite(pnl) && pnl >= 0 ? 'text-emerald-600' : 'text-rose-600';
                            const pnlLabel = Number.isFinite(pnl) ? getCurrencyString(pnl) : 'N/A';
                            const pnlPercentLabel = renderPercent(position.unrealizedGainLossPercent);
                            const lastPrice = Number.isFinite(Number(position.currentPrice)) ? Number(position.currentPrice) : null;
                            const currentPriceLabel = renderValue(position.currentPrice, { currency: true });
                            const marketValueLabel = renderValue(position.marketValue, { currency: true });
                            const avgPriceLabel = renderValue(avgPrice, { currency: true });
                            const strikeDecimals = Number.isFinite(Number(position.strike)) && Number(position.strike) % 1 === 0 ? 0 : 2;
                            const strikeLabel = renderValue(position.strike, { currency: true, decimals: strikeDecimals });
                            const expiryLabel = position.expiry ? escapeHtml(position.expiry) : 'N/A';
                            const callPutLabel = formatCallPut(position.callPut, optionSymbolRaw || position.symbol);
                            const optionSymbolDataset = escapeHtml(optionSymbolRaw || '');
                            const underlyingDataset = escapeHtml(underlyingRaw || '');

                            return `
                                <article class="border border-slate-200 rounded-xl p-4 shadow-sm bg-white">
                                    <div class="flex items-start justify-between gap-2">
                                        <div>
                                            <div class="text-sm font-semibold text-slate-800">${symbol}</div>
                                            <div class="text-xs text-slate-500">${description}</div>
                                        </div>
                                        <div class="flex flex-col items-end gap-1">
                                            <span class="inline-flex items-center px-2 py-0.5 rounded-full bg-slate-100 text-[11px] font-semibold text-slate-600 uppercase tracking-wide">${escapeHtml(callPutLabel)}</span>
                                            <span class="text-[11px] text-slate-400">Exp ${expiryLabel}</span>
                                        </div>
                                    </div>
                                    <div class="mt-3 grid grid-cols-2 gap-3 text-xs text-slate-500">
                                        <div>
                                            <div class="text-[10px] uppercase tracking-wide text-slate-400">Contracts</div>
                                            <div class="text-sm font-semibold text-slate-700">${quantity != null ? escapeHtml(String(quantity)) : 'N/A'}</div>
                                        </div>
                                        <div>
                                            <div class="text-[10px] uppercase tracking-wide text-slate-400">Avg Price</div>
                                            <div class="text-sm font-semibold text-slate-700">${escapeHtml(avgPriceLabel)}</div>
                                        </div>
                                        <div>
                                            <div class="text-[10px] uppercase tracking-wide text-slate-400">Last</div>
                                            <div class="text-sm font-semibold text-slate-700">${escapeHtml(currentPriceLabel)}</div>
                                        </div>
                                        <div>
                                            <div class="text-[10px] uppercase tracking-wide text-slate-400">Market Value</div>
                                            <div class="text-sm font-semibold text-slate-700">${escapeHtml(marketValueLabel)}</div>
                                        </div>
                                        <div>
                                            <div class="text-[10px] uppercase tracking-wide text-slate-400">Strike</div>
                                            <div class="text-sm font-semibold text-slate-700">${escapeHtml(strikeLabel)}</div>
                                        </div>
                                        <div>
                                            <div class="text-[10px] uppercase tracking-wide text-slate-400">P&L</div>
                                            <div class="text-sm font-semibold ${pnlClass}">${escapeHtml(pnlLabel)} <span class="text-[11px] text-slate-400">(${escapeHtml(pnlPercentLabel)})</span></div>
                                        </div>
                                    </div>
                                    <div class="mt-3 flex items-center justify-between gap-2">
                                        <button class="inline-flex items-center gap-2 text-xs font-semibold px-3 py-2 rounded-lg bg-rose-600 text-white hover:bg-rose-700" data-action="emergency-sell" data-option-symbol="${optionSymbolDataset}" data-symbol="${underlyingDataset}" data-quantity="${quantity != null ? quantity : 0}" data-position-id="${escapeHtml(position.positionId || '')}" data-call-put="${escapeHtml(position.callPut || '')}" data-strike="${Number.isFinite(position.strike) ? position.strike : ''}" data-expiry="${escapeHtml(position.expiry || '')}" data-price="${lastPrice != null ? lastPrice : ''}">
                                            <i data-lucide="log-out" class="w-3 h-3"></i>
                                            Exit
                                        </button>
                                        <span class="text-[11px] text-slate-400">${escapeHtml(accountDetails?.accountDesc || 'Brokerage')}</span>
                                    </div>
                                </article>
                            `;
                        })
                        .join('');

                    portfolioOptionsList.innerHTML = optionCards;
                    if (portfolioEmptyState) {
                        portfolioEmptyState.classList.add('hidden');
                    }
                    evaluateAutoExitPositions(optionPositions);
                } else {
                    portfolioOptionsList.innerHTML = '';
                    if (portfolioEmptyState) {
                        const accountLabel = accountDetails?.accountDesc ? `${escapeHtml(accountDetails.accountDesc)}` : 'this account';
                        portfolioEmptyState.innerHTML = `
                            <i data-lucide="archive" class="w-6 h-6 text-slate-300 mx-auto mb-2"></i>
                            <div>No options positions in ${accountLabel}.</div>
                            <div class="text-xs text-slate-400">Refresh or run a new scan to check for updates.</div>
                        `;
                        portfolioEmptyState.classList.remove('hidden');
                    }
                }
            }

            lucide.createIcons();
        }

        // Display basic account info when portfolio fails to load
        function displayBasicAccountInfo(accountDetails) {
            if (!accountDetails) {
                return;
            }

            revealPortfolioRail();
            lastPortfolioPayload = null;
            lastPortfolioBalance = null;
            lastDayOrdersPayload = null;

            const safe = (value, fallback = '') => escapeHtml(value != null ? value : fallback);
            const accountIdDisplay = escapeHtml(getAccountIdString(accountDetails?.accountId || accountDetails?.accountIdKey || 'N/A'));

            if (accountSummary) {
                accountSummary.innerHTML = `
                    <div class="bg-slate-50 border border-slate-100 rounded-lg p-3">
                        <div class="text-[11px] uppercase tracking-wide text-slate-400">Account ID</div>
                        <div class="text-base font-semibold text-blue-600">${accountIdDisplay}</div>
                    </div>
                    <div class="bg-slate-50 border border-slate-100 rounded-lg p-3">
                        <div class="text-[11px] uppercase tracking-wide text-slate-400">Account Type</div>
                        <div class="text-base font-semibold text-emerald-600">${safe(accountDetails.accountType, 'INDIVIDUAL')}</div>
                    </div>
                    <div class="bg-slate-50 border border-slate-100 rounded-lg p-3">
                        <div class="text-[11px] uppercase tracking-wide text-slate-400">Mode</div>
                        <div class="text-base font-semibold text-purple-600">${safe(accountDetails.accountMode, 'CASH')}</div>
                    </div>
                    <div class="bg-slate-50 border border-slate-100 rounded-lg p-3">
                        <div class="text-[11px] uppercase tracking-wide text-slate-400">Status</div>
                        <div class="text-base font-semibold text-amber-600">${safe(accountDetails.accountStatus, 'ACTIVE')}</div>
                    </div>
                `;
            }

            if (portfolioOptionsList) {
                portfolioOptionsList.innerHTML = `
                    <div class="border border-slate-200 bg-slate-50 rounded-lg p-4 text-sm text-slate-600">
                        <div class="flex items-start gap-2">
                            <i data-lucide="info" class="w-4 h-4 text-blue-500 mt-0.5"></i>
                            <div>
                                <div class="font-semibold text-slate-700">Positions unavailable for this account.</div>
                                <div class="text-xs text-slate-500 mt-1">Balances are still shown above when provided by the broker.</div>
                            </div>
                        </div>
                    </div>
                `;
            }

            if (portfolioOptionsMeta) {
                portfolioOptionsMeta.textContent = '';
            }

            if (portfolioEmptyState) {
                portfolioEmptyState.classList.add('hidden');
            }

            renderDayPlPanel(null);
            lucide.createIcons();
        }

        async function loadScanConfig() {
            try {
                setSymbolsStatus('loading', 'Loading scan settings...');
                setStrategyStatus('loading', 'Loading strategy preference...');
                if (strategySelect) {
                    strategySelect.disabled = true;
                }
                const response = await fetch('/api/scan/config');
                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}`);
                }
                const data = await response.json();
                if (!data.success) {
                    throw new Error(data.error || 'Failed to load configuration.');
                }
                applyScanConfig(data.config, { updateInput: true, updateStatus: true });
                if (symbolsInput) {
                    symbolsInput.value = currentSymbolList.join(', ');
                }
                if (strategySelect) {
                    strategySelect.disabled = false;
                }
            } catch (error) {
                console.error('Failed to load scan config:', error);
                setSymbolsStatus('error', 'Unable to load symbol list');
                setStrategyStatus('error', 'Unable to load strategy preference');
                if (strategySelect) {
                    strategySelect.disabled = false;
                }
            }
        }

        async function saveScanSettings() {
            if (!saveSymbolsBtn) return;
            const normalized = normalizeSymbolInput(symbolsInput ? symbolsInput.value : currentSymbolList);
            if (normalized.length === 0) {
                setSymbolsStatus('warning', 'Enter at least one valid ticker symbol.');
                return;
            }
            if (normalized.length > 24) {
                setSymbolsStatus('warning', 'Please limit the list to 24 symbols.');
                return;
            }

            const selectedStrategyRaw = strategySelect ? strategySelect.value : currentStrategy;
            const selectedStrategy = typeof selectedStrategyRaw === 'string' ? selectedStrategyRaw.trim().toLowerCase() : currentStrategy;
            const strategyValid = Object.prototype.hasOwnProperty.call(STRATEGY_METADATA, selectedStrategy);
            if (!strategyValid) {
                setStrategyStatus('error', 'Choose a valid strategy (day_trade or swing_trade).');
                return;
            }

            const noSymbolChanges = arraysShallowEqual(normalized, currentSymbolList);
            const noStrategyChange = selectedStrategy === currentStrategy;
            if (noSymbolChanges && noStrategyChange) {
                setSymbolsStatus('info', 'No scan setting changes detected.');
                const label = formatStrategyLabel(currentStrategy);
                setStrategyStatus('info', `${label} • ${formatStrategyDescription(currentStrategy)}`);
                return;
            }

            saveSymbolsBtn.disabled = true;
            if (strategySelect) {
                strategySelect.disabled = true;
            }
            saveSymbolsBtn.innerHTML = '<i data-lucide="loader" class="w-4 h-4 animate-spin"></i> Saving...';
            lucide.createIcons();
            setSymbolsStatus('loading', 'Saving scan settings...');
            setStrategyStatus('loading', 'Applying strategy preference...');

            try {
                const response = await fetch('/api/scan/config', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ symbols: normalized, strategy: selectedStrategy })
                });
                const data = await response.json();
                if (!response.ok || !data.success) {
                    throw new Error(data.error || 'Failed to update scan settings.');
                }
                if (symbolsInput) {
                    symbolsInput.value = normalized.join(', ');
                }
                applyScanConfig(data.config, { updateInput: false, updateStatus: false });
                currentSymbolList = Array.from(normalized);
                currentStrategy = selectedStrategy;
                setSymbolsStatus('success', `Scan settings updated (${formatSymbolSummary(normalized)})`);
                const label = formatStrategyLabel(selectedStrategy);
                const description = formatStrategyDescription(selectedStrategy);
                setStrategyStatus('success', `${label} • ${description}`);
                await fetchRecommendations();
            } catch (error) {
                console.error('Scan settings save failed:', error);
                const message = error?.message || 'Failed to update scan settings.';
                setSymbolsStatus('error', message);
                setStrategyStatus('error', message);
            } finally {
                saveSymbolsBtn.disabled = false;
                if (strategySelect) {
                    strategySelect.disabled = false;
                }
                saveSymbolsBtn.innerHTML = '<i data-lucide="save" class="w-4 h-4"></i> Save Scan Settings';
                lucide.createIcons();
            }
        }

        // Load initial data
        async function loadInitialData() {
            // Initialize header balance display
            updateHeaderBalance(null);
            updateScanStatus(null);
            await loadScanConfig();
            await fetchRecommendations();
            startRecommendationsPolling();
            initializePortfolioRail();
        }

        loadInitialData();
    </script>
</body>
</html>

