<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Trade Streamer</title>
    <link rel="icon" type="image/svg+xml" href="/favicon.svg">
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://unpkg.com/lucide@latest/dist/umd/lucide.js"></script>
    <style>
        body {
            font-family: "Inter", "SF Pro Text", "SF Pro Display", -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
            font-feature-settings: "ss01" on, "ss02" on;
        }
    </style>
</head>
<body class="bg-gray-100 min-h-screen">
    <div class="container mx-auto px-4 py-8">
        <!-- Header -->
        <div class="bg-white rounded-lg shadow-md p-6 mb-6">
            <div class="flex justify-between items-center">
                <div class="flex flex-wrap items-center gap-6 sm:gap-8">
                    <img src="/logo.svg" alt="Trade Streamer" class="h-10 w-auto sm:h-12">
                </div>
                <div class="flex items-start gap-3">
                    <div class="text-right">
                        <div id="headerBalance" class="text-2xl font-bold text-green-600">$****</div>
                        <div class="text-sm text-gray-500">Account Balance</div>
                    </div>
                    <button id="toggleSensitiveBtn" class="inline-flex items-center gap-2 text-sm text-gray-500 hover:text-gray-700 border border-gray-200 rounded-lg px-3 py-2 bg-white" type="button">
                        <i id="toggleSensitiveIcon" data-lucide="eye-off" class="w-4 h-4"></i>
                        <span id="toggleSensitiveLabel">Show Details</span>
                    </button>
                </div>
            </div>
            <h1 class="sr-only">Trade Streamer – AI Strategy Playbooks for Day Trading</h1>
        </div>

        <div class="flex justify-end gap-2 mb-4">
            <button id="collapseLeftBtn" type="button" class="inline-flex items-center gap-2 text-xs font-semibold text-slate-600 hover:text-slate-800 border border-slate-200 rounded-lg px-3 py-2 bg-white shadow-sm">
                <i id="collapseLeftIcon" data-lucide="chevron-left" class="w-4 h-4"></i>
                <span id="collapseLeftLabel">Hide Scan Panel</span>
            </button>
            <button id="collapseRightBtn" type="button" class="inline-flex items-center gap-2 text-xs font-semibold text-slate-600 hover:text-slate-800 border border-slate-200 rounded-lg px-3 py-2 bg-white shadow-sm">
                <i id="collapseRightIcon" data-lucide="chevron-right" class="w-4 h-4"></i>
                <span id="collapseRightLabel">Hide Portfolio Rail</span>
            </button>
        </div>

    <div id="layoutGrid" class="xl:grid xl:grid-cols-[320px_minmax(0,1.4fr)_360px] gap-8 items-start">
            <aside id="scanSidebar" class="space-y-6 xl:sticky xl:top-6">
                <div class="bg-white rounded-xl shadow-md border border-slate-100 p-6" id="scanPanel">
                    <div class="flex items-start justify-between gap-3">
                        <div class="flex-1 space-y-3">
                            <div class="flex flex-wrap items-center gap-3">
                                <button id="scanBtn" class="bg-blue-600 hover:bg-blue-700 text-white px-5 py-2.5 rounded-lg font-semibold flex items-center gap-2">
                                    <i data-lucide="search" class="w-5 h-5"></i>
                                    Scan for Trades
                                </button>
                                <span class="text-xs font-semibold uppercase tracking-wide text-emerald-600">Portfolio auto-sync enabled</span>
                            </div>
                            <div id="scanStatus" class="text-sm text-slate-600 flex items-center gap-2 rounded-lg border border-slate-200 bg-slate-50 px-3 py-2">
                                <i data-lucide="clock" class="w-4 h-4"></i>
                                Waiting for first scan
                            </div>
                        </div>
                        <button id="toggleScanPanelBtn" type="button" class="inline-flex items-center gap-1 text-xs font-semibold text-slate-500 hover:text-slate-700 border border-slate-200 rounded-lg px-2.5 py-2 bg-white" aria-expanded="true">
                            <i id="toggleScanPanelIcon" data-lucide="chevron-up" class="w-4 h-4"></i>
                            <span id="toggleScanPanelLabel">Collapse</span>
                        </button>
                    </div>
                    <div id="scanPanelBody" class="mt-5 space-y-5">
                        <div class="space-y-2">
                            <div class="flex items-center justify-between">
                                <label for="symbolsInput" class="text-sm font-semibold text-slate-700">Symbols to scan</label>
                                <span class="text-[11px] uppercase tracking-wide text-slate-400">Max 24</span>
                            </div>
                            <div class="flex flex-col gap-2">
                                <input id="symbolsInput" type="text" class="border border-slate-300 rounded-lg px-3 py-2 text-sm focus:outline-none focus:ring-2 focus:ring-blue-500" placeholder="SPY, QQQ, AAPL, ...">
                                <button id="saveSymbolsBtn" class="bg-slate-800 hover:bg-slate-900 text-white px-4 py-2 rounded-lg font-semibold flex items-center gap-2 justify-center">
                                    <i data-lucide="save" class="w-4 h-4"></i>
                                    Save Scan Settings
                                </button>
                            </div>
                            <div id="symbolsStatus" class="text-xs text-slate-500 flex items-center gap-2">
                                <i data-lucide="info" class="w-4 h-4"></i>
                                Loading scan settings...
                            </div>
                        </div>
                        <div class="space-y-2">
                            <label for="strategySelect" class="text-sm font-semibold text-slate-700">Strategy focus</label>
                            <select id="strategySelect" class="w-full border border-slate-300 rounded-lg px-3 py-2 text-sm focus:outline-none focus:ring-2 focus:ring-blue-500">
                                <option value="day_trade">Day Trade (intraday)</option>
                                <option value="swing_trade">Swing Trade (multi-day)</option>
                            </select>
                            <div id="strategyStatus" class="text-xs text-slate-500 flex items-center gap-2">
                                <i data-lucide="info" class="w-4 h-4"></i>
                                Loading strategy preference...
                            </div>
                        </div>
                        <div class="border-t border-slate-200 pt-4 space-y-3">
                            <div class="text-xs font-semibold uppercase tracking-wide text-slate-500">Quick Insights</div>
                            <ul id="scanInsights" class="space-y-2 text-sm text-slate-600">
                                <li class="flex items-start gap-2">
                                    <i data-lucide="activity" class="w-4 h-4 text-blue-500 mt-0.5"></i>
                                    <span>Awaiting initial scan...</span>
                                </li>
                            </ul>
                        </div>
                    </div>
                </div>
            </aside>

            <main class="space-y-6">
                <div id="recommendationSummary" class="grid grid-cols-1 sm:grid-cols-2 xl:grid-cols-4 gap-4"></div>
                <div id="recommendations" class="grid grid-cols-1 lg:grid-cols-2 2xl:grid-cols-3 gap-6 auto-rows-fr">
                    <!-- Recommendations will be inserted here -->
                </div>
            </main>

            <aside id="portfolioRail" class="hidden xl:flex xl:flex-col gap-4">
                <div id="portfolioSummaryCard" class="bg-white rounded-xl shadow-md border border-slate-100 p-5 space-y-4">
                    <div class="flex items-start justify-between gap-3">
                        <div>
                            <h2 class="text-lg font-semibold text-slate-800 flex items-center gap-2">
                                <i data-lucide="wallet" class="w-4 h-4 text-emerald-500"></i>
                                Options Portfolio
                            </h2>
                            <span id="portfolioStatus" class="text-xs text-slate-500"></span>
                        </div>
                        <button id="refreshPortfolioBtn" type="button" class="inline-flex items-center gap-2 text-xs font-semibold text-slate-600 hover:text-slate-800 border border-slate-200 rounded-lg px-3 py-2 bg-white">
                            <i data-lucide="refresh-cw" class="w-3 h-3"></i>
                            <span>Refresh</span>
                        </button>
                    </div>
                    <div id="accountSummary" class="grid grid-cols-2 gap-3 text-sm"></div>
                </div>
                <div class="bg-white rounded-xl shadow-md border border-slate-100 p-4 flex-1 overflow-y-auto max-h-[70vh]">
                    <div class="flex items-center justify-between mb-3">
                        <h3 class="text-sm font-semibold text-slate-700 flex items-center gap-2">
                            <i data-lucide="zap" class="w-4 h-4 text-purple-500"></i>
                            Active Options
                        </h3>
                        <span class="text-[11px] uppercase tracking-wide text-slate-400" id="portfolioOptionsMeta"></span>
                    </div>
                    <div id="portfolioOptionsList" class="space-y-3"></div>
                    <div id="portfolioEmptyState" class="text-center text-sm text-slate-500 bg-slate-50 border border-dashed border-slate-200 rounded-lg p-5 hidden">
                        <i data-lucide="archive" class="w-6 h-6 text-slate-300 mx-auto mb-2"></i>
                        <div>No options positions yet.</div>
                        <div class="text-xs text-slate-400">Connect your account or refresh to see updates.</div>
                    </div>
                </div>
            </aside>
        </div>
    </div>

    <script>
        // Initialize Lucide icons
        lucide.createIcons();

    const scanSidebar = document.getElementById('scanSidebar');
    const scanBtn = document.getElementById('scanBtn');
    const scanStatus = document.getElementById('scanStatus');
    const recommendations = document.getElementById('recommendations');
    const portfolioRail = document.getElementById('portfolioRail');
    const accountSummary = document.getElementById('accountSummary');
    const portfolioOptionsList = document.getElementById('portfolioOptionsList');
    const portfolioEmptyState = document.getElementById('portfolioEmptyState');
    const portfolioOptionsMeta = document.getElementById('portfolioOptionsMeta');
    const layoutGrid = document.getElementById('layoutGrid');
    const collapseLeftBtn = document.getElementById('collapseLeftBtn');
    const collapseLeftIcon = document.getElementById('collapseLeftIcon');
    const collapseLeftLabel = document.getElementById('collapseLeftLabel');
    const collapseRightBtn = document.getElementById('collapseRightBtn');
    const collapseRightIcon = document.getElementById('collapseRightIcon');
    const collapseRightLabel = document.getElementById('collapseRightLabel');
    const toggleScanPanelBtn = document.getElementById('toggleScanPanelBtn');
    const toggleScanPanelIcon = document.getElementById('toggleScanPanelIcon');
    const toggleScanPanelLabel = document.getElementById('toggleScanPanelLabel');
    const scanPanelBody = document.getElementById('scanPanelBody');
        const headerBalance = document.getElementById('headerBalance');
        const toggleSensitiveBtn = document.getElementById('toggleSensitiveBtn');
        const refreshPortfolioBtn = document.getElementById('refreshPortfolioBtn');
        const portfolioStatus = document.getElementById('portfolioStatus');
        const symbolsInput = document.getElementById('symbolsInput');
        const saveSymbolsBtn = document.getElementById('saveSymbolsBtn');
        const symbolsStatus = document.getElementById('symbolsStatus');
        const strategySelect = document.getElementById('strategySelect');
        const strategyStatus = document.getElementById('strategyStatus');
    const recommendationSummary = document.getElementById('recommendationSummary');
    const scanInsights = document.getElementById('scanInsights');

        const POLL_INTERVAL_MS = 15000;
        const PORTFOLIO_REFRESH_INTERVAL_MS = 60000;
        let recommendationsTimer = null;
        let portfolioRefreshTimer = null;
        let currentSymbolList = [];
        let currentStrategy = 'day_trade';
    let lastRecommendationStats = null;
    let lastScanMetaPayload = null;
    let scanPanelCollapsed = false;
    let leftSidebarCollapsed = false;
    let rightSidebarCollapsed = false;
        let revealSensitive = false;
        let lastBalancePayload = null;
        let lastPortfolioPayload = null;
        let lastPortfolioBalance = null;
        let lastPortfolioRefreshAt = null;
        let portfolioAutoInitStarted = false;

        // Update header balance display
        function updateHeaderBalance(balanceData) {
            lastBalancePayload = balanceData || null;
            renderHeaderBalance();
        }

        function escapeHtml(text) {
            if (text == null) return '';
            return text.toString().replace(/[&<>"']/g, (char) => {
                const map = { '&': '&amp;', '<': '&lt;', '>': '&gt;', '"': '&quot;', "'": '&#39;' };
                return map[char] || char;
            });
        }

        function normalizeSymbolInput(value) {
            if (!value) return [];
            const parts = Array.isArray(value) ? value : value.split(/[,\s]+/);
            const seen = new Set();
            const out = [];
            for (const raw of parts) {
                if (!raw) continue;
                const symbol = raw.toString().trim().toUpperCase();
                if (!symbol) continue;
                if (!/^[A-Z0-9.\-]{1,12}$/.test(symbol)) continue;
                if (seen.has(symbol)) continue;
                seen.add(symbol);
                out.push(symbol);
            }
            return out;
        }

        function arraysShallowEqual(a, b) {
            if (!Array.isArray(a) || !Array.isArray(b)) return false;
            if (a.length !== b.length) return false;
            for (let i = 0; i < a.length; i++) {
                if (a[i] !== b[i]) return false;
            }
            return true;
        }

        function setScanPanelCollapsed(collapsed) {
            if (!scanPanelBody || !toggleScanPanelBtn || !toggleScanPanelIcon || !toggleScanPanelLabel) return;
            scanPanelCollapsed = !!collapsed;
            if (scanPanelCollapsed) {
                scanPanelBody.classList.add('hidden');
                toggleScanPanelBtn.setAttribute('aria-expanded', 'false');
                toggleScanPanelIcon.setAttribute('data-lucide', 'chevron-down');
                toggleScanPanelLabel.textContent = 'Expand';
            } else {
                scanPanelBody.classList.remove('hidden');
                toggleScanPanelBtn.setAttribute('aria-expanded', 'true');
                toggleScanPanelIcon.setAttribute('data-lucide', 'chevron-up');
                toggleScanPanelLabel.textContent = 'Collapse';
            }
            lucide.createIcons();
        }

        if (toggleScanPanelBtn) {
            toggleScanPanelBtn.addEventListener('click', () => {
                setScanPanelCollapsed(!scanPanelCollapsed);
            });
        }

        setScanPanelCollapsed(false);

        function updateLayoutColumns() {
            if (!layoutGrid) return;
            if (leftSidebarCollapsed && rightSidebarCollapsed) {
                layoutGrid.style.gridTemplateColumns = 'minmax(0, 1fr)';
            } else if (leftSidebarCollapsed) {
                layoutGrid.style.gridTemplateColumns = 'minmax(0, 1fr) 360px';
            } else if (rightSidebarCollapsed) {
                layoutGrid.style.gridTemplateColumns = '320px minmax(0, 1fr)';
            } else {
                layoutGrid.style.gridTemplateColumns = '320px minmax(0, 1.4fr) 360px';
            }
        }

        function updateSidebarToggleUI() {
            if (collapseLeftIcon && collapseLeftLabel) {
                if (leftSidebarCollapsed) {
                    collapseLeftIcon.setAttribute('data-lucide', 'chevron-right');
                    collapseLeftLabel.textContent = 'Show Scan Panel';
                } else {
                    collapseLeftIcon.setAttribute('data-lucide', 'chevron-left');
                    collapseLeftLabel.textContent = 'Hide Scan Panel';
                }
            }
            if (collapseRightIcon && collapseRightLabel) {
                if (rightSidebarCollapsed) {
                    collapseRightIcon.setAttribute('data-lucide', 'chevron-left');
                    collapseRightLabel.textContent = 'Show Portfolio Rail';
                } else {
                    collapseRightIcon.setAttribute('data-lucide', 'chevron-right');
                    collapseRightLabel.textContent = 'Hide Portfolio Rail';
                }
            }
            lucide.createIcons();
        }

        function updateSidebarVisibility() {
            if (scanSidebar) {
                scanSidebar.style.display = leftSidebarCollapsed ? 'none' : '';
            }
            if (portfolioRail) {
                portfolioRail.style.display = rightSidebarCollapsed ? 'none' : '';
            }
            updateLayoutColumns();
            updateSidebarToggleUI();
        }

        if (collapseLeftBtn) {
            collapseLeftBtn.addEventListener('click', () => {
                leftSidebarCollapsed = !leftSidebarCollapsed;
                updateSidebarVisibility();
            });
        }

        if (collapseRightBtn) {
            collapseRightBtn.addEventListener('click', () => {
                rightSidebarCollapsed = !rightSidebarCollapsed;
                updateSidebarVisibility();
            });
        }

        updateSidebarVisibility();

        function formatSymbolSummary(list) {
            if (!Array.isArray(list) || list.length === 0) {
                return 'No symbols configured';
            }
            const preview = list.slice(0, 6);
            const suffix = list.length > preview.length ? '…' : '';
            const countLabel = `${list.length} symbol${list.length === 1 ? '' : 's'}`;
            return `${countLabel}: ${preview.join(', ')}${suffix}`;
        }

        const STRATEGY_METADATA = {
            day_trade: {
                label: 'Day Trade',
                description: 'Intraday focus with faster exits and 0DTE exposure.'
            },
            swing_trade: {
                label: 'Swing Trade',
                description: 'Multi-day positioning with weekly expirations.'
            }
        };

        function resolveStrategyMeta(strategy) {
            const key = typeof strategy === 'string' ? strategy.trim().toLowerCase() : '';
            return STRATEGY_METADATA[key] || {
                label: key || 'Unknown',
                description: 'Custom strategy mode.'
            };
        }

        function formatStrategyLabel(strategy) {
            return resolveStrategyMeta(strategy).label;
        }

        function formatStrategyDescription(strategy) {
            return resolveStrategyMeta(strategy).description;
        }

        function setStatusDisplay(target, state, message, { infoIcon = 'info' } = {}) {
            if (!target) return;
            const states = {
                loading: { icon: 'loader', color: 'text-blue-600', iconClass: 'animate-spin' },
                success: { icon: 'check', color: 'text-green-600', iconClass: '' },
                error: { icon: 'x', color: 'text-red-600', iconClass: '' },
                warning: { icon: 'alert-triangle', color: 'text-yellow-600', iconClass: '' },
                info: { icon: infoIcon, color: 'text-gray-600', iconClass: '' }
            };
            const meta = states[state] || states.info;
            const iconHtml = `<i data-lucide="${meta.icon}" class="w-4 h-4 ${meta.iconClass}"></i>`;
            target.innerHTML = `
                <div class="flex items-center gap-2 text-sm ${meta.color}">
                    ${iconHtml}
                    <span>${escapeHtml(message)}</span>
                </div>
            `;
            lucide.createIcons();
        }

        function setSymbolsStatus(state, message) {
            setStatusDisplay(symbolsStatus, state, message, { infoIcon: 'list' });
        }

        function setStrategyStatus(state, message) {
            setStatusDisplay(strategyStatus, state, message, { infoIcon: 'shuffle' });
        }

        function updateRecommendationSummary(stats) {
            if (!recommendationSummary) return;

            if (!stats || !stats.totalSymbols) {
                recommendationSummary.innerHTML = `
                    <div class="bg-white border border-dashed border-slate-200 rounded-xl p-5 flex items-center gap-3 text-slate-500">
                        <i data-lucide="compass" class="w-5 h-5"></i>
                        <div>
                            <div class="text-sm font-semibold">Awaiting trade ideas</div>
                            <div class="text-xs text-slate-400">Run a scan to populate AI suggestions.</div>
                        </div>
                    </div>
                `;
                lucide.createIcons();
                return;
            }

            const cards = [
                {
                    icon: 'radar',
                    title: 'Trade Ideas',
                    value: stats.totalSymbols,
                    accent: 'text-blue-600',
                    description: `${stats.totalIdeas} AI reads · ${stats.providerCount} providers`,
                },
                {
                    icon: 'check-circle',
                    title: 'Approved',
                    value: stats.decisionCounts.approve,
                    accent: 'text-emerald-600',
                    description: `${stats.callPutCounts.call} calls · ${stats.callPutCounts.put} puts`,
                },
                {
                    icon: 'alert-triangle',
                    title: 'Caution',
                    value: stats.decisionCounts.caution,
                    accent: 'text-amber-600',
                    description: `${stats.decisionCounts.reject} rejects · ${stats.decisionCounts.unknown} needs review`,
                },
                {
                    icon: 'shield-alert',
                    title: 'Risk Flags',
                    value: stats.riskFlagSymbols.length,
                    accent: 'text-rose-600',
                    description: `${stats.totalRiskFlags} alerts across watchlist`,
                },
            ];

            recommendationSummary.innerHTML = cards
                .map((card) => `
                    <div class="bg-white rounded-xl border border-slate-200 shadow-sm p-5 flex items-start gap-3">
                        <div class="shrink-0 rounded-lg bg-slate-100 p-2">
                            <i data-lucide="${card.icon}" class="w-5 h-5 ${card.accent}"></i>
                        </div>
                        <div class="space-y-1">
                            <div class="text-xs font-semibold uppercase tracking-wide text-slate-400">${escapeHtml(card.title)}</div>
                            <div class="text-2xl font-bold ${card.accent}">${escapeHtml(String(card.value))}</div>
                            <div class="text-xs text-slate-500">${escapeHtml(card.description)}</div>
                        </div>
                    </div>
                `)
                .join('');

            lucide.createIcons();
        }

        function renderSidebarInsights() {
            if (!scanInsights) return;

            const insights = [];
            const strategyLabel = formatStrategyLabel(currentStrategy);
            const symbolSummary = escapeHtml(formatSymbolSummary(currentSymbolList));

            insights.push(`
                <li class="flex items-start gap-2">
                    <i data-lucide="list" class="w-4 h-4 text-slate-500 mt-0.5"></i>
                    <span><span class="font-semibold text-slate-700">${symbolSummary}</span></span>
                </li>
            `);

            insights.push(`
                <li class="flex items-start gap-2">
                    <i data-lucide="shuffle" class="w-4 h-4 text-indigo-500 mt-0.5"></i>
                    <span><span class="font-semibold text-slate-700">${escapeHtml(strategyLabel)}</span> strategy active</span>
                </li>
            `);

            if (lastRecommendationStats) {
                const stats = lastRecommendationStats;
                const formatDecisionLabel = (value) => {
                    if (!value) return '';
                    return String(value)
                        .replace(/[_-]+/g, ' ')
                        .replace(/\b\w/g, (char) => char.toUpperCase());
                };
                insights.push(`
                    <li class="flex items-start gap-2">
                        <i data-lucide="sparkles" class="w-4 h-4 text-emerald-500 mt-0.5"></i>
                        <span>${escapeHtml(String(stats.totalSymbols))} symbols · ${escapeHtml(String(stats.totalIdeas))} AI reads · ${escapeHtml(String(stats.providerCount))} providers</span>
                    </li>
                `);

                const decisionSummary = Object.entries(stats.decisionCounts || {})
                    .filter(([, count]) => Number(count) > 0)
                    .map(([key, count]) => `${escapeHtml(String(count))} ${escapeHtml(formatDecisionLabel(key))}`)
                    .join(' · ');
                if (decisionSummary) {
                    insights.push(`
                        <li class="flex items-start gap-2">
                            <i data-lucide="scale" class="w-4 h-4 text-indigo-500 mt-0.5"></i>
                            <span>${decisionSummary}</span>
                        </li>
                    `);
                }

                const cp = stats.callPutCounts || {};
                if ((cp.call || 0) > 0 || (cp.put || 0) > 0) {
                    insights.push(`
                        <li class="flex items-start gap-2">
                            <i data-lucide="columns" class="w-4 h-4 text-slate-500 mt-0.5"></i>
                            <span>${escapeHtml(String(cp.call || 0))} calls · ${escapeHtml(String(cp.put || 0))} puts</span>
                        </li>
                    `);
                }

                if (stats.topSignals.length) {
                    const signalText = stats.topSignals
                        .map((sig) => `${escapeHtml(sig.name)} (${escapeHtml(String(sig.count))})`)
                        .join(', ');
                    insights.push(`
                        <li class="flex items-start gap-2">
                            <i data-lucide="activity" class="w-4 h-4 text-blue-500 mt-0.5"></i>
                            <span>Top signals: ${signalText}</span>
                        </li>
                    `);
                }

                if (stats.riskFlagSymbols.length) {
                    const risky = stats.riskFlagSymbols
                        .slice(0, 3)
                        .map((sym) => escapeHtml(sym))
                        .join(', ');
                    const suffix = stats.riskFlagSymbols.length > 3 ? '…' : '';
                    insights.push(`
                        <li class="flex items-start gap-2">
                            <i data-lucide="alert-octagon" class="w-4 h-4 text-rose-500 mt-0.5"></i>
                            <span>Risk alerts on ${escapeHtml(String(stats.riskFlagSymbols.length))} symbols (${risky}${suffix})</span>
                        </li>
                    `);
                }
            }

            if (lastScanMetaPayload) {
                const providerLabel = Array.isArray(lastScanMetaPayload.providers)
                    ? lastScanMetaPayload.providers
                        .map((p) => (p && typeof p === 'object' ? p.provider || '' : p))
                        .filter(Boolean)
                        .map((name) => escapeHtml(String(name).toUpperCase()))
                        .join(', ')
                    : null;
                const lastRun = lastScanMetaPayload.completedAt
                    ? `Last scan ${escapeHtml(formatRelativeTime(lastScanMetaPayload.completedAt))}`
                    : 'Scan pending';
                const providerDetail = providerLabel ? ` · ${providerLabel}` : '';
                insights.push(`
                    <li class="flex items-start gap-2">
                        <i data-lucide="history" class="w-4 h-4 text-slate-500 mt-0.5"></i>
                        <span>${lastRun}${providerDetail}</span>
                    </li>
                `);

                const failureCount = Array.isArray(lastScanMetaPayload.errors)
                    ? lastScanMetaPayload.errors.filter((err) => err && (err.provider || err.message)).length
                    : 0;
                if (failureCount) {
                    insights.push(`
                        <li class="flex items-start gap-2">
                            <i data-lucide="alert-circle" class="w-4 h-4 text-amber-500 mt-0.5"></i>
                            <span>${escapeHtml(String(failureCount))} provider${failureCount === 1 ? '' : 's'} reported errors</span>
                        </li>
                    `);
                }
            }

            if (!insights.length) {
                insights.push(`
                    <li class="flex items-start gap-2">
                        <i data-lucide="info" class="w-4 h-4 text-slate-400 mt-0.5"></i>
                        <span>Awaiting initial scan...</span>
                    </li>
                `);
            }

            scanInsights.innerHTML = insights.join('');
            lucide.createIcons();
        }

        const SENSITIVE_MASK = '****';

        function maskAccountId(value) {
            const str = value != null ? String(value) : 'N/A';
            if (!str || str === 'N/A') {
                return 'N/A';
            }
            const alphanumeric = str.replace(/[^A-Za-z0-9]/g, '');
            const tail = alphanumeric.slice(-4) || str.slice(-4) || '----';
            return `${SENSITIVE_MASK}${tail}`;
        }

        function getCurrencyString(value) {
            if (!Number.isFinite(value)) {
                return revealSensitive ? 'N/A' : `$${SENSITIVE_MASK}`;
            }
            const formatted = `$${value.toFixed(2)}`;
            return revealSensitive ? formatted : `$${SENSITIVE_MASK}`;
        }

        function getAccountIdString(value) {
            const str = value != null ? String(value) : 'N/A';
            return revealSensitive ? str : maskAccountId(str);
        }

        function renderHeaderBalance() {
            if (!headerBalance) return;
            const rawValue = lastBalancePayload?.totalAccountValue;
            const numericValue = Number(rawValue);
            const safeValue = Number.isFinite(numericValue) ? numericValue : null;
            headerBalance.textContent = getCurrencyString(safeValue);
        }

        function refreshPortfolioDisplay() {
            if (lastPortfolioPayload) {
                displayPortfolio(lastPortfolioPayload, lastPortfolioBalance, { skipStore: true });
            }
        }

        function setPortfolioStatus(message, tone = 'info') {
            if (!portfolioStatus) return;
            const toneClassMap = {
                info: 'text-gray-500',
                success: 'text-green-600',
                warning: 'text-amber-600',
                error: 'text-red-600',
            };
            portfolioStatus.textContent = message || '';
            portfolioStatus.classList.remove('text-gray-500', 'text-green-600', 'text-amber-600', 'text-red-600');
            if (message) {
                portfolioStatus.classList.add(toneClassMap[tone] || toneClassMap.info);
                portfolioStatus.classList.remove('hidden');
            } else {
                portfolioStatus.classList.add('hidden');
            }
        }

        function clearPortfolioRefreshTimer() {
            if (portfolioRefreshTimer) {
                clearInterval(portfolioRefreshTimer);
                portfolioRefreshTimer = null;
            }
        }

        function schedulePortfolioRefresh(accountIdKey) {
            clearPortfolioRefreshTimer();
            if (!accountIdKey) {
                return;
            }
            portfolioRefreshTimer = setInterval(() => {
                loadAccountDetails(accountIdKey, { showLoading: false, reason: 'auto' });
            }, PORTFOLIO_REFRESH_INTERVAL_MS);
        }

        function formatRefreshTimestamp(timestamp) {
            if (!timestamp) {
                return '';
            }
            return new Date(timestamp).toLocaleTimeString([], { hour: '2-digit', minute: '2-digit', second: '2-digit' });
        }

        setPortfolioStatus('');

        function updateSensitiveControls() {
            if (!toggleSensitiveBtn) return;
            const iconName = revealSensitive ? 'eye' : 'eye-off';
            const label = revealSensitive ? 'Hide Details' : 'Show Details';
            toggleSensitiveBtn.innerHTML = `
                <i data-lucide="${iconName}" class="w-4 h-4"></i>
                <span>${label}</span>
            `;
            lucide.createIcons();
        }

        if (toggleSensitiveBtn) {
            updateSensitiveControls();
            toggleSensitiveBtn.addEventListener('click', () => {
                revealSensitive = !revealSensitive;
                updateSensitiveControls();
                renderHeaderBalance();
                refreshPortfolioDisplay();
            });
        }

        function applyScanConfig(config, options = {}) {
            const { updateInput = false, updateStatus = true } = options;
            if (!config) return;
            const list = Array.isArray(config.symbols) ? config.symbols : [];
            currentSymbolList = list;
            const configuredStrategy = typeof config.strategy === 'string' ? config.strategy : currentStrategy;
            currentStrategy = configuredStrategy;
            if (strategySelect && strategySelect.value !== configuredStrategy) {
                strategySelect.value = configuredStrategy;
            }
            if (updateInput && symbolsInput && document.activeElement !== symbolsInput) {
                symbolsInput.value = list.join(', ');
            }
            if (updateStatus) {
                if (list.length === 0) {
                    setSymbolsStatus('warning', 'No symbols configured. Add tickers to start scanning.');
                } else {
                    setSymbolsStatus('info', formatSymbolSummary(list));
                }
                const strategyLabel = formatStrategyLabel(configuredStrategy);
                const strategyDescription = formatStrategyDescription(configuredStrategy);
                setStrategyStatus('info', `${strategyLabel} • ${strategyDescription}`);
            }
            renderSidebarInsights();
        }

        function renderScanStatus({ icon, color = 'text-gray-600', message, suffix = '', iconClass = '' }) {
            if (!scanStatus) return;
            scanStatus.innerHTML = `
                <div class="flex items-center gap-2 ${color}">
                    <i data-lucide="${icon}" class="w-4 h-4 ${iconClass}"></i>
                    <span>${escapeHtml(message)}</span>
                    ${suffix}
                </div>
            `;
            lucide.createIcons();
        }

        function formatRelativeTime(isoString) {
            if (!isoString) {
                return 'never';
            }

            const deltaMs = Date.now() - Date.parse(isoString);
            if (!Number.isFinite(deltaMs) || deltaMs < 0) {
                return new Date(isoString).toLocaleTimeString();
            }

            const seconds = Math.floor(deltaMs / 1000);
            if (seconds < 60) {
                return `${seconds}s ago`;
            }

            const minutes = Math.floor(seconds / 60);
            if (minutes < 60) {
                return `${minutes}m ago`;
            }

            const hours = Math.floor(minutes / 60);
            return `${hours}h ago`;
        }

        function updateScanStatus(payload, error) {
            if (payload?.config) {
                applyScanConfig(payload.config, { updateInput: false, updateStatus: true });
            }

            if (payload?.scanMeta) {
                lastScanMetaPayload = payload.scanMeta;
            } else if (payload?.results?.scanMeta) {
                lastScanMetaPayload = payload.results.scanMeta;
            }

            const symbolSuffix = currentSymbolList.length
                ? `<span class="text-xs text-gray-400 ml-2">[${escapeHtml(currentSymbolList.join(', '))}]</span>`
                : '';
            const strategyLabel = formatStrategyLabel(currentStrategy);
            const strategySuffix = currentStrategy
                ? `<span class="text-xs text-indigo-500 ml-2 uppercase">Strategy: ${escapeHtml(strategyLabel)}</span>`
                : '';
            const statusSuffix = `${symbolSuffix}${strategySuffix}`;

            const finish = () => {
                renderSidebarInsights();
            };

            if (error) {
                renderScanStatus({ icon: 'x', color: 'text-red-600', message: error, suffix: statusSuffix });
                finish();
                return;
            }

            if (!payload) {
                renderScanStatus({ icon: 'clock', message: 'Waiting for first scan', suffix: symbolSuffix });
                finish();
                return;
            }

            const { isScanning, scanMeta, lastError } = payload;

            if (isScanning) {
                renderScanStatus({ icon: 'loader', color: 'text-blue-600', iconClass: 'animate-spin', message: `Running ${strategyLabel} scan...`, suffix: statusSuffix });
                finish();
                return;
            }

            if (scanMeta?.success) {
                const completed = formatRelativeTime(scanMeta.completedAt);
                const sourceLabel = scanMeta.source || 'auto';
                const providerList = Array.isArray(scanMeta.providers)
                    ? scanMeta.providers.map((p) => (p && typeof p === 'object' ? p.provider || '' : p)).filter(Boolean)
                    : Array.isArray(payload?.results?.providers)
                        ? payload.results.providers.map((p) => (p && typeof p === 'object' ? p.provider || '' : p)).filter(Boolean)
                        : [];
                const providerLabel = providerList.length
                    ? ` | AI: ${providerList.map((name) => String(name).toUpperCase()).join(', ')}`
                    : '';
                const failureCount = Array.isArray(scanMeta.errors)
                    ? scanMeta.errors.filter((err) => err && err.provider && err.message).length
                    : 0;
                const failureLabel = failureCount
                    ? ` | ${failureCount} provider${failureCount === 1 ? '' : 's'} failed`
                    : '';
                renderScanStatus({
                    icon: 'check',
                    color: 'text-green-600',
                    message: `Last scan ${completed} (${sourceLabel}${providerLabel}${failureLabel})`,
                    suffix: statusSuffix
                });
                finish();
                return;
            }

            if (scanMeta && !scanMeta.success) {
                const completed = formatRelativeTime(scanMeta.completedAt);
                const errorMessage = lastError?.message || 'Scan failed';
                renderScanStatus({
                    icon: 'alert-triangle',
                    color: 'text-yellow-600',
                    message: `Scan error ${completed}: ${errorMessage}`,
                    suffix: statusSuffix
                });
                finish();
                return;
            }

            renderScanStatus({ icon: 'clock', message: 'Waiting for first scan', suffix: statusSuffix });
            finish();
        }

        async function fetchRecommendations() {
            try {
                const response = await fetch('/api/recommendations');
                const data = await response.json();

                if (data.results) {
                    displayRecommendations(data.results.parsed, data.results);
                }

                updateScanStatus(data);
            } catch (err) {
                console.error('Failed to fetch recommendations:', err);
                updateScanStatus(null, 'Disconnected from scanner');
            }
        }

        function startRecommendationsPolling() {
            if (recommendationsTimer) {
                return;
            }

            recommendationsTimer = setInterval(fetchRecommendations, POLL_INTERVAL_MS);
        }

        // Scan for trades
        scanBtn.addEventListener('click', async () => {
            scanBtn.disabled = true;
            scanBtn.innerHTML = '<i data-lucide="loader" class="w-5 h-5 animate-spin"></i> Scanning...';
            lucide.createIcons();
            const suffix = currentSymbolList.length
                ? `<span class="text-xs text-gray-400 ml-2">[${escapeHtml(currentSymbolList.join(', '))}]</span>`
                : '';
            const strategyLabel = formatStrategyLabel(currentStrategy);
            const strategySuffix = currentStrategy
                ? `<span class="text-xs text-indigo-500 ml-2 uppercase">Strategy: ${escapeHtml(strategyLabel)}</span>`
                : '';
            renderScanStatus({
                icon: 'loader',
                color: 'text-blue-600',
                iconClass: 'animate-spin',
                message: `Running manual ${strategyLabel} scan...`,
                suffix: `${suffix}${strategySuffix}`
            });

            try {
                const response = await fetch('/api/scan', { method: 'POST' });
                const data = await response.json();

                if (data.success) {
                    await fetchRecommendations();
                } else {
                    throw new Error(data.error);
                }
            } catch (error) {
                console.error('Scan failed:', error);
                const alreadyRunning = error.message === 'Scan already in progress';
                const msg = alreadyRunning ? 'Scan already running, please wait...' : 'Manual scan failed: ' + error.message;
                updateScanStatus(null, msg);
            } finally {
                scanBtn.disabled = false;
                scanBtn.innerHTML = '<i data-lucide="search" class="w-5 h-5"></i> Scan for Trades';
                lucide.createIcons();
            }
        });

        if (saveSymbolsBtn) {
            saveSymbolsBtn.addEventListener('click', async () => {
                await saveScanSettings();
            });
        }

        if (symbolsInput) {
            symbolsInput.addEventListener('keydown', async (event) => {
                if (event.key === 'Enter' && !event.shiftKey) {
                    event.preventDefault();
                    await saveScanSettings();
                }
            });
        }

        if (strategySelect) {
            strategySelect.addEventListener('change', async () => {
                await saveScanSettings();
            });
        }

        let portfolioConfigLoaded = false;
        const portfolioConfig = { defaultAccountIdKey: null };

        async function loadPortfolioConfig() {
            if (portfolioConfigLoaded) {
                return portfolioConfig;
            }
            try {
                const response = await fetch('/api/portfolio/config');
                if (response.ok) {
                    const data = await response.json();
                    if (data?.success && data.defaultAccountIdKey) {
                        portfolioConfig.defaultAccountIdKey = data.defaultAccountIdKey;
                    }
                }
            } catch (error) {
                console.warn('Portfolio config fetch failed:', error);
            } finally {
                portfolioConfigLoaded = true;
            }
            return portfolioConfig;
        }

        function resolveDefaultAccountIdKey(accounts) {
            if (!Array.isArray(accounts) || accounts.length === 0) {
                return null;
            }
            if (portfolioConfig.defaultAccountIdKey) {
                const match = accounts.find((acc) => acc.accountIdKey === portfolioConfig.defaultAccountIdKey);
                if (match) {
                    return match.accountIdKey;
                }
            }
            return accounts[0].accountIdKey;
        }

        function revealPortfolioRail() {
            if (portfolioRail) {
                portfolioRail.classList.remove('hidden');
            }
        }

        function renderPortfolioLoadingState() {
            if (accountSummary) {
                accountSummary.innerHTML = `
                    <div class="col-span-2 flex items-center justify-center py-6">
                        <div class="flex items-center gap-2 text-slate-500">
                            <i data-lucide="loader" class="w-4 h-4 animate-spin text-blue-500"></i>
                            <span>Loading account details…</span>
                        </div>
                    </div>
                `;
            }
            if (portfolioOptionsList) {
                portfolioOptionsList.innerHTML = `
                    <div class="border border-dashed border-slate-200 rounded-lg p-4 animate-pulse bg-slate-50">
                        <div class="h-3 bg-slate-200 rounded w-1/2 mb-3"></div>
                        <div class="space-y-2">
                            <div class="h-2.5 bg-slate-200 rounded"></div>
                            <div class="h-2.5 bg-slate-200 rounded"></div>
                            <div class="h-2.5 bg-slate-200 rounded w-2/3"></div>
                        </div>
                    </div>
                `;
            }
            if (portfolioOptionsMeta) {
                portfolioOptionsMeta.textContent = 'Loading…';
            }
            if (portfolioEmptyState) {
                portfolioEmptyState.classList.add('hidden');
            }
            lucide.createIcons();
        }

        async function initializePortfolioRail({ force = false } = {}) {
            if (portfolioAutoInitStarted && !force) {
                return;
            }
            portfolioAutoInitStarted = true;

            try {
                await loadPortfolioConfig();
            } catch (error) {
                console.warn('Portfolio config unavailable:', error);
            }

            try {
                const accountsResponse = await fetch('/api/portfolio/accounts');
                const accountsData = await accountsResponse.json();

                if (!accountsData.success || !Array.isArray(accountsData.accounts) || accountsData.accounts.length === 0) {
                    throw new Error('No accounts found. Please verify brokerage authentication.');
                }

                window.availableAccounts = accountsData.accounts;
                const accountIdKey = resolveDefaultAccountIdKey(accountsData.accounts);
                if (!accountIdKey) {
                    throw new Error('Default account not available.');
                }

                window.selectedAccountIdKey = accountIdKey;
                revealPortfolioRail();
                renderPortfolioLoadingState();
                setPortfolioStatus('Loading latest portfolio…', 'info');
                updateHeaderBalance(null);
                await loadAccountDetails(accountIdKey, { showLoading: false, reason: 'manual' });
                schedulePortfolioRefresh(accountIdKey);
                if (scanStatus) {
                    scanStatus.innerHTML = '<i data-lucide="check" class="w-4 h-4 text-green-600"></i> Portfolio synced';
                    lucide.createIcons();
                }
            } catch (error) {
                console.error('Portfolio auto-load error:', error);
                if (scanStatus) {
                    scanStatus.innerHTML = '<i data-lucide="x" class="w-4 h-4 text-red-600"></i> Portfolio error: ' + escapeHtml(error.message);
                    lucide.createIcons();
                }
                setPortfolioStatus('Portfolio load failed: ' + error.message, 'error');
                portfolioAutoInitStarted = false;
            }
        }

        async function loadAccountDetails(accountIdKey, { showLoading = true, reason = 'manual' } = {}) {
            if (!accountIdKey) {
                return false;
            }

            if (showLoading) {
                revealPortfolioRail();
                renderPortfolioLoadingState();
                setPortfolioStatus('Loading account data…', 'info');
            } else {
                setPortfolioStatus(reason === 'auto' ? 'Auto refresh in progress…' : 'Refreshing portfolio…', 'info');
            }

            try {
                let balanceData = null;
                try {
                    const balanceResponse = await fetch(`/api/portfolio/${accountIdKey}/balance`);
                    if (balanceResponse.ok) {
                        const balanceResult = await balanceResponse.json();
                        if (balanceResult.success) {
                            balanceData = balanceResult.balance;
                        }
                    }
                } catch (balanceErr) {
                    console.log('Balance API not available, continuing with basic info');
                }

                const portfolioResponse = await fetch(`/api/portfolio/${accountIdKey}`);
                const portfolioData = await portfolioResponse.json();

                if (!portfolioData.success) {
                    throw new Error(portfolioData.error || 'Failed to load portfolio');
                }

                revealPortfolioRail();
                displayPortfolio(portfolioData.portfolio, balanceData);
                updateHeaderBalance(balanceData);
                lastPortfolioRefreshAt = Date.now();
                const label = reason === 'auto' ? 'Auto refreshed' : 'Updated';
                const suffix = reason === 'auto' ? '' : ' · auto refresh every 60s';
                setPortfolioStatus(`${label} at ${formatRefreshTimestamp(lastPortfolioRefreshAt)}${suffix}`, 'success');
                return true;
            } catch (error) {
                console.error('Account fetch error:', error);
                const accountDetails = window.availableAccounts?.find((acc) => acc.accountIdKey === accountIdKey);
                if (accountDetails) {
                    displayBasicAccountInfo(accountDetails);
                    updateHeaderBalance(null);
                } else {
                    if (accountSummary) {
                        accountSummary.innerHTML = `
                            <div class="col-span-2 text-center py-6">
                                <i data-lucide="alert-triangle" class="w-6 h-6 text-red-500 mx-auto mb-2"></i>
                                <div class="text-red-600 font-medium">Error Loading Account</div>
                                <div class="text-xs text-slate-500 mt-1">${escapeHtml(error.message)}</div>
                            </div>
                        `;
                    }
                }
                if (portfolioOptionsList) {
                    portfolioOptionsList.innerHTML = `
                        <div class="border border-red-200 bg-red-50 text-red-600 rounded-lg p-4 text-sm">
                            <div class="flex items-center gap-2">
                                <i data-lucide="alert-octagon" class="w-4 h-4"></i>
                                <span>Unable to load positions.</span>
                            </div>
                            <div class="text-xs text-red-500 mt-2">${escapeHtml(error.message)}</div>
                        </div>
                    `;
                }
                if (portfolioOptionsMeta) {
                    portfolioOptionsMeta.textContent = '';
                }
                if (portfolioEmptyState) {
                    portfolioEmptyState.classList.add('hidden');
                }
                lucide.createIcons();
                setPortfolioStatus(`Portfolio refresh failed: ${error.message}`, 'error');
                return false;
            }
        }

        if (refreshPortfolioBtn) {
            refreshPortfolioBtn.addEventListener('click', async () => {
                if (!window.selectedAccountIdKey) {
                    setPortfolioStatus('Attempting to load default account…', 'info');
                    await initializePortfolioRail({ force: true });
                    return;
                }
                await loadAccountDetails(window.selectedAccountIdKey, { showLoading: false, reason: 'manual' });
                schedulePortfolioRefresh(window.selectedAccountIdKey);
            });
        }

        window.addEventListener('beforeunload', () => {
            clearPortfolioRefreshTimer();
        });

        if (portfolioOptionsList) {
            portfolioOptionsList.addEventListener('click', async (event) => {
                const button = event.target.closest('button[data-action]');
                if (!button) {
                    return;
                }

                const action = button.dataset.action;
                if (action !== 'emergency-sell') {
                    return;
                }

                event.preventDefault();
                const accountIdKey = window.selectedAccountIdKey;
                if (!accountIdKey) {
                    alert('Load your default account before submitting an emergency sell.');
                    return;
                }

                const optionSymbol = button.dataset.optionSymbol || button.dataset.symbol;
                const quantity = Number(button.dataset.quantity);
                if (!optionSymbol) {
                    alert('Missing option symbol for this position.');
                    return;
                }
                if (!Number.isFinite(quantity) || quantity === 0) {
                    alert('Unable to determine position size for emergency sell.');
                    return;
                }

                const callPut = button.dataset.callPut || null;
                const strike = button.dataset.strike !== '' ? Number(button.dataset.strike) : null;
                const expiry = button.dataset.expiry || null;
                const positionId = button.dataset.positionId || null;

                const confirmationLines = [
                    `Account: ${accountIdKey}`,
                    `Option: ${optionSymbol}`,
                    `Quantity: ${quantity}`,
                    '',
                    'This will submit a market exit at the current market price immediately.',
                    'Existing stop or limit orders are not automatically cancelled.',
                    'Continue?',
                ];

                if (!window.confirm(confirmationLines.join('\n'))) {
                    return;
                }

                const payload = {
                    optionSymbol,
                    symbol: button.dataset.symbol || optionSymbol,
                    quantity,
                    positionId,
                    callPut,
                    strike: Number.isFinite(strike) ? strike : null,
                    expiry,
                };

                const originalLabel = button.innerHTML;
                button.disabled = true;
                button.innerHTML = '<i data-lucide="loader" class="w-4 h-4 animate-spin"></i>';
                lucide.createIcons();

                try {
                    const response = await fetch(`/api/portfolio/${accountIdKey}/options/emergency-sell`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(payload),
                    });

                    let data = null;
                    try {
                        data = await response.json();
                    } catch (parseError) {
                        data = null;
                    }

                    if (!response.ok || !data?.success) {
                        const errorMessage = data?.error || `Broker rejected order (HTTP ${response.status})`;
                        throw new Error(errorMessage);
                    }

                    const messageLines = ['Emergency sell submitted successfully.'];
                    if (data.order?.orderId) {
                        messageLines.push(`Order ID: ${data.order.orderId}`);
                    }
                    if (data.order?.previewId) {
                        messageLines.push(`Preview ID: ${data.order.previewId}`);
                    }
                    if (Array.isArray(data.order?.messages) && data.order.messages.length) {
                        messageLines.push(`Broker notes: ${data.order.messages.join('; ')}`);
                    }

                    alert(messageLines.join('\n'));
                    await loadAccountDetails(accountIdKey, { showLoading: false, reason: 'manual' });
                } catch (err) {
                    alert(`Emergency sell failed: ${err.message}`);
                } finally {
                    button.disabled = false;
                    button.innerHTML = originalLabel;
                    lucide.createIcons();
                }
            });
        }

        // Display recommendations
        function displayRecommendations(recs, context = {}) {
            recommendations.innerHTML = '';

            const normalizeDecision = (value) => {
                const token = String(value || '').toLowerCase();
                if (token.includes('approve') || token.includes('strong') || token === 'buy') return 'approve';
                if (token.includes('caution') || token.includes('hold') || token === 'watch') return 'caution';
                if (token.includes('reject') || token.includes('avoid') || token.includes('sell')) return 'reject';
                return 'unknown';
            };

            const formatPrice = (value) => {
                if (Number.isFinite(value)) {
                    return Number(value).toFixed(2);
                }
                return '—';
            };

            const formatQuantity = (value) => {
                if (Number.isFinite(value)) {
                    return String(value);
                }
                return '—';
            };

            const formatPriceLabel = (value) => {
                const raw = formatPrice(value);
                return raw === '—' ? '—' : `$${raw}`;
            };

            const slugify = (value, fallback = 'item') => {
                if (!value) return fallback;
                return String(value)
                    .toLowerCase()
                    .replace(/[^a-z0-9]+/g, '-')
                    .replace(/^-+|-+$/g, '')
                    || fallback;
            };

            const formatSideLabel = (side, contract = '') => {
                const token = typeof side === 'string' ? side.trim().toUpperCase() : '';
                if (token === 'CALL' || token === 'PUT') {
                    return token;
                }
                const text = typeof contract === 'string' ? contract.toUpperCase() : '';
                if (text.includes(' CALL')) return 'CALL';
                if (text.includes(' PUT')) return 'PUT';
                return null;
            };

            const parseExpiryDate = (value) => {
                if (!value) return null;
                const text = String(value).trim();
                if (!text) return null;
                if (/^\d{4}-\d{2}-\d{2}$/.test(text)) {
                    const iso = new Date(`${text}T00:00:00Z`);
                    return Number.isNaN(iso.getTime()) ? null : iso;
                }
                const parsed = new Date(text);
                return Number.isNaN(parsed.getTime()) ? null : parsed;
            };

            const calculateHoldGuidance = (rec, fallbackExpiry) => {
                if (rec?.ai?.holdGuidance) {
                    return rec.ai.holdGuidance;
                }
                const expiryDate = parseExpiryDate(rec?.expiry || fallbackExpiry);
                if (!expiryDate) {
                    return 'Reassess daily; exit if momentum stalls to limit theta decay.';
                }
                const now = new Date();
                const diffMs = expiryDate.getTime() - now.getTime();
                const diffDays = Math.max(0, Math.round(diffMs / (1000 * 60 * 60 * 24)));
                if (diffDays <= 1) {
                    return 'Exit or roll today—expiration is imminent and theta risk is extreme.';
                }
                if (diffDays <= 3) {
                    return `Keep a tight leash; roll or exit within ${Math.max(1, diffDays - 1)} day(s) if momentum stays flat.`;
                }
                if (diffDays <= 7) {
                    return `Review after ${Math.max(1, diffDays - 2)} day(s); plan to roll early if price fails to move.`;
                }
                return `Target follow-through within ${Math.max(2, Math.round(diffDays / 2))} day(s); exit sooner if momentum breaks.`;
            };

            const formatConfidence = (rec) => {
                const raw = rec?.ai?.confidence;
                if (typeof raw === 'number') {
                    return `${Math.round(raw)}%`;
                }
                if (typeof raw === 'string' && raw.trim()) {
                    return raw.includes('%') ? raw.trim() : `${raw.trim()}%`;
                }
                if (Number.isFinite(rec?.ai?.strength)) {
                    return `${Math.round(rec.ai.strength)}%`;
                }
                return '—';
            };

            const createSparkline = (rec) => {
                const pointsSource = Array.isArray(rec?.sparkline)
                    ? rec.sparkline
                    : Array.isArray(rec?.sparklinePoints)
                        ? rec.sparklinePoints
                        : null;

                let series = null;
                if (pointsSource && pointsSource.length >= 2) {
                    series = pointsSource
                        .map((value) => Number(value))
                        .filter((value) => Number.isFinite(value));
                } else {
                    const fallback = [rec?.stop, rec?.entry, rec?.target]
                        .map((value) => Number(value))
                        .filter((value) => Number.isFinite(value));
                    series = fallback.length >= 2 ? fallback : null;
                }

                if (!Array.isArray(series) || series.length < 2) {
                    return null;
                }

                const width = 160;
                const height = 48;
                const min = Math.min(...series);
                const max = Math.max(...series);
                const range = max - min || 1;
                const step = width / (series.length - 1);
                const path = series
                    .map((value, index) => {
                        const x = (index * step).toFixed(1);
                        const y = (height - ((value - min) / range) * height).toFixed(1);
                        return `${index === 0 ? 'M' : 'L'}${x},${y}`;
                    })
                    .join(' ');

                const firstValue = series[0];
                const lastValue = series[series.length - 1];
                let trend = 'flat';
                let strokeColor = '#6B7280';
                if (lastValue > firstValue) {
                    trend = 'up';
                    strokeColor = '#10B981';
                } else if (lastValue < firstValue) {
                    trend = 'down';
                    strokeColor = '#EF4444';
                }

                const formattedValues = series.map((value) => Number.isFinite(value) ? Number(value.toFixed(2)) : value);

                return {
                    svg: `
                        <svg viewBox="0 0 ${width} ${height}" class="w-full h-12" preserveAspectRatio="none" role="img" aria-label="Price sparkline">
                            <path d="${path}" fill="none" stroke="${strokeColor}" stroke-width="2" stroke-linecap="round" />
                        </svg>
                    `,
                    values: formattedValues,
                    trend,
                    strokeColor,
                };
            };

            const formatSignalTag = (text) => {
                if (!text) return '';
                return text
                    .toString()
                    .trim()
                    .replace(/[_-]+/g, ' ')
                    .replace(/\b\w/g, (char) => char.toUpperCase());
            };

            const extractOptionMeta = (rec) => {
                const result = {
                    strike: Number.isFinite(rec?.strike) ? rec.strike : null,
                    expiry: rec?.expiry || null,
                };
                if ((!result.expiry || !result.strike) && typeof rec?.contract === 'string') {
                    const match = rec.contract.match(/(\d{4}-\d{2}-\d{2})/);
                    if (!result.expiry && match) {
                        result.expiry = match[1];
                    }
                    const strikeMatch = rec.contract.match(/\b(\d+(?:\.\d+)?)\s*(?:C|P)\b/i);
                    if (!result.strike && strikeMatch) {
                        result.strike = Number.parseFloat(strikeMatch[1]);
                    }
                }
                return result;
            };

            if (!Array.isArray(recs) || recs.length === 0) {
                lastRecommendationStats = null;
                updateRecommendationSummary(null);
                renderSidebarInsights();
                recommendations.innerHTML = `
                    <div class="bg-white border border-dashed border-slate-200 rounded-xl p-6 text-center text-slate-500">
                        <i data-lucide="alert-circle" class="w-10 h-10 text-slate-300 mx-auto mb-3"></i>
                        <div class="text-sm font-semibold">No active trade ideas</div>
                        <div class="text-xs text-slate-400">Run a scan to surface the latest AI suggestions.</div>
                    </div>
                `;
                lucide.createIcons();
                return;
            }

            const providerSet = new Set();
            const signalFrequency = new Map();
            const riskFlagSymbols = new Set();
            let totalRiskFlags = 0;
            const decisionCounts = { approve: 0, caution: 0, reject: 0, unknown: 0 };
            const callPutCounts = { call: 0, put: 0 };

            recs.forEach((rec) => {
                const decisionKey = normalizeDecision(rec.ai?.decision);
                decisionCounts[decisionKey] = (decisionCounts[decisionKey] || 0) + 1;

                const providerKey = String(rec.ai?.provider || rec.provider || 'AI').toUpperCase();
                providerSet.add(providerKey);

                if (Array.isArray(rec.ai?.riskFlags) && rec.ai.riskFlags.length) {
                    riskFlagSymbols.add(String(rec.symbol || '').toUpperCase());
                    totalRiskFlags += rec.ai.riskFlags.filter(Boolean).length;
                }

                let sideToken = String(rec.side || '').toLowerCase();
                if (!sideToken && typeof rec.contract === 'string') {
                    const contractUpper = rec.contract.toUpperCase();
                    if (contractUpper.includes('CALL')) {
                        sideToken = 'call';
                    } else if (contractUpper.includes('PUT')) {
                        sideToken = 'put';
                    }
                }
                if (sideToken === 'call' || sideToken === 'put') {
                    callPutCounts[sideToken] = (callPutCounts[sideToken] || 0) + 1;
                }

                if (Array.isArray(rec.signals)) {
                    rec.signals.forEach((sig) => {
                        if (!sig) return;
                        const trimmed = sig.toString().trim();
                        if (!trimmed) return;
                        signalFrequency.set(trimmed, (signalFrequency.get(trimmed) || 0) + 1);
                    });
                }
            });

            const groupsMap = new Map();
            recs.forEach((rec, idx) => {
                const symbol = (rec.symbol || `UNKNOWN_${idx}`).toUpperCase();
                if (!groupsMap.has(symbol)) {
                    groupsMap.set(symbol, []);
                }
                groupsMap.get(symbol).push(rec);
            });

            const decisionRank = { approve: 3, caution: 2, reject: 1, unknown: 0 };

            const grouped = Array.from(groupsMap.entries()).map(([symbol, items]) => {
                const bestRec = items.reduce((best, item) => {
                    const itemStrength = Number.isFinite(item.ai?.strength) ? item.ai.strength : -Infinity;
                    const bestStrength = Number.isFinite(best.ai?.strength) ? best.ai.strength : -Infinity;
                    if (itemStrength > bestStrength) {
                        return item;
                    }
                    if (itemStrength === bestStrength) {
                        const itemRank = decisionRank[normalizeDecision(item.ai?.decision)] || 0;
                        const bestRank = decisionRank[normalizeDecision(best.ai?.decision)] || 0;
                        if (itemRank > bestRank) {
                            return item;
                        }
                    }
                    return best;
                }, items[0]);
                return { symbol, items, bestRec };
            });

            grouped.sort((a, b) => {
                const aStrength = Number.isFinite(a.bestRec?.ai?.strength) ? a.bestRec.ai.strength : -Infinity;
                const bStrength = Number.isFinite(b.bestRec?.ai?.strength) ? b.bestRec.ai.strength : -Infinity;
                if (bStrength !== aStrength) {
                    return bStrength - aStrength;
                }
                return a.symbol.localeCompare(b.symbol);
            });

            const topSignals = Array.from(signalFrequency.entries())
                .sort((a, b) => b[1] - a[1])
                .slice(0, 3)
                .map(([name, count]) => ({ name, count }));

            lastRecommendationStats = {
                totalSymbols: grouped.length,
                totalIdeas: recs.length,
                providerCount: providerSet.size,
                decisionCounts,
                riskFlagSymbols: Array.from(riskFlagSymbols).filter(Boolean),
                totalRiskFlags,
                topSignals,
                callPutCounts: {
                    call: callPutCounts.call || 0,
                    put: callPutCounts.put || 0,
                },
            };

            updateRecommendationSummary(lastRecommendationStats);
            renderSidebarInsights();

            const parseConfidenceValue = (value) => {
                if (value == null) return null;
                let numeric = value;
                if (typeof numeric === 'string') {
                    const stripped = numeric.replace(/%/g, '').trim();
                    if (!stripped) return null;
                    numeric = Number(stripped);
                }
                if (!Number.isFinite(numeric)) return null;
                if (numeric <= 1) {
                    numeric *= 100;
                }
                return Math.max(0, Math.min(100, Number(numeric.toFixed(1))));
            };

            const formatConfidencePercent = (value) => {
                if (!Number.isFinite(value)) return '—';
                return `${value.toFixed(0)}%`;
            };

            const verdictBadgeMeta = {
                approve: { bg: '#16A34A', text: '#FFFFFF' },
                caution: { bg: '#F59E0B', text: '#111827' },
                reject: { bg: '#DC2626', text: '#FFFFFF' },
                unknown: { bg: '#6B7280', text: '#FFFFFF' },
            };

            const getVerdictBadgeStyle = (verdictKey) => {
                const key = verdictKey && verdictBadgeMeta[verdictKey] ? verdictKey : 'unknown';
                return verdictBadgeMeta[key];
            };

            const getConfidenceToneColor = (value) => {
                if (!Number.isFinite(value)) {
                    return '#6B7280';
                }
                if (value >= 80) {
                    return '#16A34A';
                }
                if (value >= 60) {
                    return '#F59E0B';
                }
                return '#DC2626';
            };

            const signalConditionLookup = new Map([
                ['macd bullish', 'MACD histogram stays positive with signal line above zero'],
                ['high volume', 'Volume ≥ 1.3× 20-period average on confirmation candle'],
                ['support bounce', 'Price prints higher low off intraday support before entry'],
                ['near resistance', 'Break and hold above immediate resistance on strong tape'],
                ['vwap hold', 'Price holds above VWAP on 5m close prior to entry'],
                ['ema support', 'Maintain closes above EMA support zone through entry trigger'],
            ]);

            const deriveBuyConditions = (signals) => {
                const conditions = [];
                const seen = new Set();
                signals.forEach((label) => {
                    const key = label.toLowerCase();
                    if (signalConditionLookup.has(key) && !seen.has(key)) {
                        seen.add(key);
                        conditions.push(signalConditionLookup.get(key));
                    }
                });
                if (!conditions.length) {
                    conditions.push('Candle close above VWAP with expanding volume confirmation');
                }
                return conditions;
            };

            const deriveExitConditions = ({ stop, target, expiryLabel, tradePlan, holdGuidance }) => {
                const exits = [];
                if (Number.isFinite(stop)) {
                    exits.push(`Stop loss trigger at $${Number(stop).toFixed(2)} or loss of VWAP on closing basis`);
                } else {
                    exits.push('Honor hard stop per risk plan or exit if VWAP fails');
                }
                if (expiryLabel && expiryLabel !== '—') {
                    exits.push(`Time stop: exit by ${expiryLabel} if target not achieved, respect ${holdGuidance}`);
                } else {
                    exits.push(`Time stop: exit before final trading hour if target not achieved (${holdGuidance})`);
                }
                if (Array.isArray(tradePlan?.iterations) && tradePlan.iterations.length) {
                    const steps = tradePlan.iterations
                        .map((step) => {
                            const targetLabel = step.target != null ? `$${Number(step.target).toFixed(2)}` : 'strength pop';
                            return `${step.sellQty} @ ${targetLabel}`;
                        })
                        .join(', ');
                    exits.push(`Scaling plan: trim ${steps}`);
                } else if (Number.isFinite(target)) {
                    exits.push(`Scaling plan: take partials near $${Number(target).toFixed(2)} and trail remainder tightly`);
                } else {
                    exits.push('Scaling plan: scale out into local resistance levels while trailing stop-up');
                }
                return exits;
            };

            grouped.forEach(({ symbol, items, bestRec }) => {
                const focusRec = bestRec || items[0];
                const baseDecision = normalizeDecision(focusRec?.ai?.decision);
                const { strike, expiry } = extractOptionMeta(focusRec);
                const strikeLabel = Number.isFinite(strike) ? `$${strike.toFixed(strike % 1 === 0 ? 0 : 2)}` : '—';
                const sideLabel = formatSideLabel(focusRec.side, focusRec.contract);
                const strikeDescriptor = sideLabel ? `${strikeLabel} ${sideLabel}` : strikeLabel;
                const expiryLabel = expiry || '—';

                const signalSet = new Set();
                items.forEach((item) => {
                    (item.signals || []).forEach((sig) => signalSet.add(formatSignalTag(sig)));
                });
                const signalTags = Array.from(signalSet)
                    .filter(Boolean)
                    .map((label) => label.replace(/\s+/g, ' ').trim());

                const providerDetails = items
                    .slice()
                    .sort((a, b) => {
                        const providerA = String(a.ai?.provider || a.provider || '').toLowerCase();
                        const providerB = String(b.ai?.provider || b.provider || '').toLowerCase();
                        return providerA.localeCompare(providerB);
                    })
                    .map((rec) => {
                        const providerName = String(rec.ai?.provider || rec.provider || 'AI');
                        const confidenceFromAI = rec.ai?.confidence ?? rec.ai?.strength ?? null;
                        const confidence = parseConfidenceValue(confidenceFromAI);
                        const entry = Number.isFinite(rec.entry) ? Number(rec.entry) : null;
                        const stop = Number.isFinite(rec.stop) ? Number(rec.stop) : null;
                        const target = Number.isFinite(rec.target) ? Number(rec.target) : null;
                        const notes = [];
                        if (rec.ai?.notes) {
                            notes.push(rec.ai.notes);
                        }
                        if (Array.isArray(rec.ai?.riskFlags) && rec.ai.riskFlags.length) {
                            rec.ai.riskFlags.filter(Boolean).forEach((flag) => notes.push(flag));
                        }
                        if (rec.ai?.adjustments && typeof rec.ai.adjustments === 'object') {
                            const adj = Object.entries(rec.ai.adjustments)
                                .filter(([, value]) => value != null)
                                .map(([key, value]) => `${key}: ${value}`);
                            if (adj.length) {
                                notes.push(`Adjustments -> ${adj.join(', ')}`);
                            }
                        }
                        const noteLines = notes.length ? notes : ['No additional commentary'];
                        return {
                            provider: providerName,
                            confidence,
                            entry,
                            stop,
                            target,
                            noteLines,
                        };
                    });

                const confidenceValues = providerDetails
                    .map((detail) => detail.confidence)
                    .filter((value) => Number.isFinite(value));
                const confluenceScore = confidenceValues.length
                    ? confidenceValues.reduce((sum, value) => sum + value, 0) / confidenceValues.length
                    : null;
                const confluenceScoreLabel = Number.isFinite(confluenceScore) ? `${confluenceScore.toFixed(1)}%` : 'N/A';

                const confidenceSpread = confidenceValues.length >= 2
                    ? Math.max(...confidenceValues) - Math.min(...confidenceValues)
                    : 0;
                const hasDisagreement = confidenceSpread > 25;

                const entryPrice = Number.isFinite(focusRec.entry) ? Number(focusRec.entry) : null;
                const stopPrice = Number.isFinite(focusRec.stop) ? Number(focusRec.stop) : null;
                const targetPrice = Number.isFinite(focusRec.target) ? Number(focusRec.target) : null;
                let rewardToRisk = null;
                if (entryPrice != null && stopPrice != null && targetPrice != null) {
                    const risk = entryPrice - stopPrice;
                    const reward = targetPrice - entryPrice;
                    if (risk > 0 && reward > 0) {
                        rewardToRisk = reward / risk;
                    }
                }

                const spreadPct = Number.isFinite(focusRec?.spread_pct)
                    ? Number(focusRec.spread_pct)
                    : Number.isFinite(focusRec?.option_details?.spread_pct)
                        ? Number(focusRec.option_details.spread_pct)
                        : Number.isFinite(focusRec?.liquidity?.spread_pct)
                            ? Number(focusRec.liquidity.spread_pct)
                            : null;
                const wideSpreadRisk = Number.isFinite(spreadPct) && spreadPct > 5;

                let verdict = baseDecision;
                if (rewardToRisk != null && rewardToRisk < 2.5) {
                    verdict = 'reject';
                } else if (Number.isFinite(confluenceScore) && confluenceScore < 70) {
                    verdict = 'caution';
                }
                if (!verdict || verdict === 'unknown') {
                    verdict = Number.isFinite(confluenceScore) && confluenceScore >= 70 ? 'approve' : 'caution';
                }

                const holdGuidance = calculateHoldGuidance(focusRec, expiryLabel);
                const buyConditions = deriveBuyConditions(Array.from(signalSet));
                const tradePlanPayload = focusRec.tradePlan
                    ? focusRec.tradePlan
                    : (Array.isArray(focusRec.scalingPlan) ? { iterations: focusRec.scalingPlan } : null);
                const exitConditions = deriveExitConditions({
                    stop: stopPrice,
                    target: targetPrice,
                    expiryLabel,
                    tradePlan: tradePlanPayload,
                    holdGuidance,
                });

                const sparklineData = createSparkline(focusRec);

                const providerRowsHtml = providerDetails
                    .map((detail, index) => {
                        const entryCell = detail.entry != null ? detail.entry.toFixed(2) : '—';
                        const stopCell = detail.stop != null ? detail.stop.toFixed(2) : '—';
                        const targetCell = detail.target != null ? detail.target.toFixed(2) : '—';
                        const rowStyle = index % 2 === 1 ? ' style="background-color:#F9FAFB;"' : '';
                        const confidenceColor = getConfidenceToneColor(detail.confidence);
                        return `
                            <tr${rowStyle} class="text-sm text-[#111827]">
                                <td class="px-4 py-2 font-semibold">${escapeHtml(detail.provider)}</td>
                                <td class="px-4 py-2 text-center font-semibold" style="color:${confidenceColor};">${escapeHtml(formatConfidencePercent(detail.confidence))}</td>
                                <td class="px-4 py-2 text-right text-[#6B7280]">${escapeHtml(entryCell)}</td>
                                <td class="px-4 py-2 text-right text-[#6B7280]">${escapeHtml(stopCell)}</td>
                                <td class="px-4 py-2 text-right text-[#6B7280]">${escapeHtml(targetCell)}</td>
                            </tr>
                        `;
                    })
                    .join('');

                const providerInsightsHtml = providerDetails
                    .map((detail) => {
                        const noteItems = detail.noteLines.length ? detail.noteLines : ['No additional commentary'];
                        const bullets = noteItems
                            .map((line) => `<li class="flex gap-2 leading-tight text-sm text-[#6B7280]"><span class="text-[#6B7280]">•</span><span>${escapeHtml(line)}</span></li>`)
                            .join('');
                        return `
                            <div class="space-y-2">
                                <div class="text-sm font-semibold text-[#111827]">${escapeHtml(detail.provider)}</div>
                                <ul class="space-y-1 ml-2">${bullets}</ul>
                            </div>
                        `;
                    })
                    .join('<div class="h-px bg-[#E5E7EB]"></div>');

                let decisionSummary = 'Trade marked caution until confluence or risk profile improves.';
                if (verdict === 'approve') {
                    decisionSummary = 'Trade approved because confluence meets thresholds and reward-to-risk is acceptable.';
                } else if (verdict === 'reject') {
                    decisionSummary = 'Trade rejected because reward-to-risk fails to clear minimum threshold.';
                }
                if (wideSpreadRisk) {
                    decisionSummary += ' Wide spread risk requires careful fills.';
                } else if (hasDisagreement) {
                    decisionSummary += ' Provider confidence spread indicates mixed conviction.';
                }

                const rulesLines = [
                    'If CONFLUENCE_SCORE < 70 → VERDICT = CAUTION',
                    'If R/R < 2.5 → VERDICT = REJECT',
                ];
                if (hasDisagreement) {
                    rulesLines.push('Provider disagreement flagged because confidence spread exceeds 25%');
                }
                if (wideSpreadRisk) {
                    rulesLines.push('Wide spread risk flagged because bid/ask spread exceeds 5%');
                }

                const buyListHtml = buyConditions
                    .map((item) => `<li class="flex gap-2 leading-tight"><span class="text-[#6B7280]">•</span><span>${escapeHtml(item)}</span></li>`)
                    .join('');

                const exitListHtml = exitConditions
                    .map((item) => `<li class="flex gap-2 leading-tight"><span class="text-[#6B7280]">•</span><span>${escapeHtml(item)}</span></li>`)
                    .join('');

                const scalingPlanItems = (() => {
                    if (Array.isArray(tradePlanPayload?.iterations) && tradePlanPayload.iterations.length) {
                        return tradePlanPayload.iterations.map((step, index) => {
                            const qtyLabel = step.sellQty != null ? String(step.sellQty) : `Step ${index + 1}`;
                            const targetLabel = step.target != null ? `$${Number(step.target).toFixed(2)}` : 'Momentum strength';
                            return `${qtyLabel} at ${targetLabel}`;
                        });
                    }
                    if (Number.isFinite(targetPrice)) {
                        return [
                            `Trim partial near $${targetPrice.toFixed(2)}`,
                            'Trail remainder once first target fills',
                        ];
                    }
                    return ['No scaling instructions provided'];
                })();

                const scalingListHtml = scalingPlanItems
                    .map((item) => `<li class="flex gap-2 leading-tight"><span class="text-[#6B7280]">•</span><span>${escapeHtml(item)}</span></li>`)
                    .join('');

                const rulesListHtml = rulesLines
                    .map((item) => `<li class="flex gap-2 leading-tight text-sm"><span class="text-[#6B7280]">•</span><span>${escapeHtml(item)}</span></li>`)
                    .join('');

                const badgeStyle = getVerdictBadgeStyle(verdict);
                const confluenceColor = getConfidenceToneColor(confluenceScore);
                const sparklineTrendLabel = sparklineData
                    ? sparklineData.trend === 'up'
                        ? 'Uptrend'
                        : sparklineData.trend === 'down'
                            ? 'Downtrend'
                            : 'Flat'
                    : 'Unavailable';
                const sparklineVisual = sparklineData
                    ? `<div class="flex flex-col gap-2"><div class="w-full">${sparklineData.svg}</div><div class="text-xs text-[#6B7280]">Data points: ${sparklineData.values.map((value) => Number(value).toFixed(2)).join(', ')}</div></div>`
                    : '<div class="text-sm text-[#6B7280]">Insufficient data for sparkline.</div>';

                const tagChipsHtml = signalTags.length
                    ? signalTags
                        .map((tag) => `<span class="inline-flex items-center px-2.5 py-1 rounded-full text-xs font-medium" style="background-color:#F3F4F6;color:#374151;">${escapeHtml(tag)}</span>`)
                        .join('')
                    : '<span class="inline-flex items-center px-2.5 py-1 rounded-full text-xs font-medium" style="background-color:#F3F4F6;color:#374151;">No signals</span>';

                recommendations.innerHTML += `
                    <article class="bg-white border border-[#E5E7EB] shadow-sm rounded-3xl p-6 space-y-6 text-[#111827]">
                        <header class="flex flex-wrap items-start justify-between gap-4">
                            <div class="space-y-3">
                                <div class="text-xs uppercase tracking-[0.3em] text-[#6B7280]">Ticker</div>
                                <div class="text-3xl font-semibold">${escapeHtml(symbol)}</div>
                                <div class="flex flex-wrap gap-4 text-sm text-[#6B7280]">
                                    <span><span class="uppercase tracking-wide text-xs text-[#6B7280]">Strike&nbsp;</span><strong class="text-[#111827]">${escapeHtml(strikeDescriptor)}</strong></span>
                                    <span><span class="uppercase tracking-wide text-xs text-[#6B7280]">Expiry&nbsp;</span><strong class="text-[#111827]">${escapeHtml(expiryLabel)}</strong></span>
                                </div>
                            </div>
                            <div class="flex flex-col items-end gap-3">
                                <span class="inline-flex items-center px-3 py-1.5 rounded-full text-xs font-semibold shadow-sm" style="background-color:${badgeStyle.bg};color:${badgeStyle.text};">${escapeHtml(verdict.toUpperCase())}</span>
                                <div class="text-xs font-medium text-[#6B7280]">Confluence Score:&nbsp;<span style="color:${confluenceColor};">${escapeHtml(confluenceScoreLabel)}</span></div>
                            </div>
                        </header>

                        <div class="flex flex-wrap gap-2">${tagChipsHtml}</div>

                        <div class="h-px bg-[#E5E7EB]"></div>

                        <section class="space-y-3">
                            <h3 class="text-sm font-semibold uppercase tracking-wide text-[#111827]">Comparison Grid</h3>
                            <div class="overflow-hidden border border-[#E5E7EB] rounded-2xl">
                                <table class="w-full text-sm text-[#111827]">
                                    <thead class="bg-white text-xs uppercase tracking-wide" style="color:#64748B;">
                                        <tr>
                                            <th class="px-4 py-2 text-left">Provider</th>
                                            <th class="px-4 py-2 text-center">Confidence</th>
                                            <th class="px-4 py-2 text-right">Entry</th>
                                            <th class="px-4 py-2 text-right">Stop</th>
                                            <th class="px-4 py-2 text-right">Target</th>
                                        </tr>
                                    </thead>
                                    <tbody>${providerRowsHtml}</tbody>
                                </table>
                            </div>
                        </section>

                        <div class="h-px bg-[#E5E7EB]"></div>

                        <section class="space-y-3">
                            <h3 class="flex items-center gap-2 text-sm font-semibold text-[#111827]"><span class="text-base">🧠</span>AI Insights</h3>
                            <div class="space-y-4">${providerInsightsHtml}</div>
                        </section>

                        <div class="h-px bg-[#E5E7EB]"></div>

                        <section class="space-y-2">
                            <h3 class="text-sm font-semibold text-[#111827]">Decision Summary</h3>
                            <p class="text-sm text-[#6B7280] leading-relaxed">${escapeHtml(decisionSummary)}</p>
                        </section>

                        <div class="h-px bg-[#E5E7EB]"></div>

                        <section class="space-y-3">
                            <h3 class="flex items-center gap-2 text-sm font-semibold text-[#111827]"><span class="text-base">✅</span>Buy Conditions</h3>
                            <ul class="space-y-1 text-sm text-[#111827]">${buyListHtml}</ul>
                        </section>

                        <section class="space-y-3">
                            <h3 class="flex items-center gap-2 text-sm font-semibold text-[#111827]"><span class="text-base">🛑</span>Exit Conditions</h3>
                            <ul class="space-y-1 text-sm text-[#111827]">${exitListHtml}</ul>
                        </section>

                        <section class="space-y-3">
                            <h3 class="flex items-center gap-2 text-sm font-semibold text-[#111827]"><span class="text-base">📈</span>Scaling Plan</h3>
                            <ul class="space-y-1 text-sm text-[#111827]">${scalingListHtml}</ul>
                        </section>

                        <section class="space-y-3">
                            <h3 class="text-sm font-semibold text-[#111827]">Rules Enforced</h3>
                            <ul class="space-y-1 text-sm text-[#111827]">${rulesListHtml}</ul>
                        </section>

                        <div class="h-px bg-[#E5E7EB]"></div>

                        <section class="space-y-2">
                            <div class="flex items-center justify-between text-sm font-semibold text-[#111827]">
                                <span>Sparkline Trend</span>
                                <span class="text-xs uppercase tracking-wide" style="color:${sparklineData ? sparklineData.strokeColor : '#6B7280'};">${sparklineTrendLabel}</span>
                            </div>
                            <div class="rounded-2xl border border-[#E5E7EB] bg-[#F9FAFB] p-4">
                                ${sparklineVisual}
                            </div>
                        </section>
                    </article>
                `;
            });

            lucide.createIcons();
        }

        // Display portfolio
        function displayPortfolio(portfolio, balanceData = null, { skipStore = false } = {}) {
            if (!portfolio) {
                return;
            }

            if (!skipStore) {
                lastPortfolioPayload = portfolio;
                lastPortfolioBalance = balanceData || null;
            }

            revealPortfolioRail();

            const accountIdKey = portfolio?.account?.accountIdKey || window.selectedAccountIdKey;
            const accountDetails = window.availableAccounts?.find((acc) => acc.accountIdKey === accountIdKey);
            const primaryAccountId = accountDetails?.accountId || balanceData?.accountId || portfolio.account?.accountId || 'N/A';
            const summaryItems = [];

            if (balanceData) {
                const availableCash = Number(balanceData.moneyMktBalance ?? balanceData.cashAvailableForInvestment ?? balanceData.cashBalance ?? 0);
                const totalValue = Number(balanceData.totalAccountValue ?? 0);
                const buyingPower = Number(balanceData.cashBuyingPower ?? balanceData.marginBuyingPower ?? 0);
                summaryItems.push(
                    {
                        label: 'Account ID',
                        value: getAccountIdString(balanceData.accountId || primaryAccountId),
                        accent: 'text-blue-600',
                    },
                    {
                        label: 'Available Cash',
                        value: getCurrencyString(availableCash),
                        accent: 'text-emerald-600',
                    },
                    {
                        label: 'Total Value',
                        value: getCurrencyString(totalValue),
                        accent: 'text-purple-600',
                    },
                    {
                        label: 'Buying Power',
                        value: getCurrencyString(buyingPower),
                        accent: 'text-amber-600',
                    }
                );
            } else {
                summaryItems.push(
                    {
                        label: 'Account ID',
                        value: getAccountIdString(primaryAccountId),
                        accent: 'text-blue-600',
                    },
                    {
                        label: 'Account Type',
                        value: accountDetails?.accountType || 'INDIVIDUAL',
                        accent: 'text-emerald-600',
                    },
                    {
                        label: 'Account Mode',
                        value: accountDetails?.accountMode || 'CASH',
                        accent: 'text-purple-600',
                    },
                    {
                        label: 'Status',
                        value: accountDetails?.accountStatus || 'ACTIVE',
                        accent: 'text-amber-600',
                    }
                );
            }

            if (accountSummary) {
                accountSummary.innerHTML = summaryItems
                    .map((item) => `
                        <div class="bg-slate-50 border border-slate-100 rounded-lg p-3">
                            <div class="text-[11px] uppercase tracking-wide text-slate-400">${escapeHtml(item.label)}</div>
                            <div class="text-base font-semibold ${item.accent}">${escapeHtml(String(item.value))}</div>
                        </div>
                    `)
                    .join('');
            }

            const positions = Array.isArray(portfolio.positions) ? portfolio.positions : [];
            const optionPositions = positions.filter((position) => {
                if (!position) {
                    return false;
                }
                const desc = position.symbolDescription ? position.symbolDescription.toLowerCase() : '';
                const sym = position.symbol || '';
                return (
                    desc.includes('call') ||
                    desc.includes('put') ||
                    desc.includes('option') ||
                    sym.includes(' ') ||
                    /\d{6}[CP]\d+/.test(sym)
                );
            });

            const hasOptions = optionPositions.length > 0;
            const totalMarketValue = optionPositions.reduce((sum, pos) => {
                const value = Number(pos.marketValue);
                return Number.isFinite(value) ? sum + value : sum;
            }, 0);

            if (portfolioOptionsMeta) {
                if (hasOptions) {
                    portfolioOptionsMeta.textContent = `${optionPositions.length} position${optionPositions.length === 1 ? '' : 's'} · ${getCurrencyString(totalMarketValue)}`;
                } else {
                    portfolioOptionsMeta.textContent = '';
                }
            }

            if (portfolioOptionsList) {
                if (hasOptions) {
                    const renderValue = (value, { currency = false, fallback = 'N/A', decimals = 2 } = {}) => {
                        const numeric = Number(value);
                        if (!Number.isFinite(numeric)) {
                            return fallback;
                        }
                        if (currency) {
                            return getCurrencyString(numeric);
                        }
                        return numeric.toFixed(decimals);
                    };

                    const renderPercent = (value) => {
                        const numeric = Number(value);
                        if (!Number.isFinite(numeric)) {
                            return 'N/A';
                        }
                        return `${numeric.toFixed(2)}%`;
                    };

                    const formatCallPut = (value, fallbackSymbol) => {
                        const token = String(value || '').toUpperCase();
                        if (token === 'CALL' || token === 'PUT') {
                            return token;
                        }
                        const upperSym = String(fallbackSymbol || '').toUpperCase();
                        if (upperSym.includes(' CALL')) return 'CALL';
                        if (upperSym.includes(' PUT')) return 'PUT';
                        return 'OPTION';
                    };

                    const optionCards = optionPositions
                        .map((position) => {
                            const symbol = escapeHtml(position.symbol || 'N/A');
                            const description = escapeHtml(position.symbolDescription || '');
                            const quantity = Number.isFinite(Number(position.quantity)) ? Number(position.quantity) : null;
                            const avgPrice = position.pricePaid || position.averagePrice;
                            const pnl = Number(position.unrealizedGainLoss);
                            const pnlClass = Number.isFinite(pnl) && pnl >= 0 ? 'text-emerald-600' : 'text-rose-600';
                            const pnlLabel = Number.isFinite(pnl) ? getCurrencyString(pnl) : 'N/A';
                            const pnlPercentLabel = renderPercent(position.unrealizedGainLossPercent);
                            const currentPriceLabel = renderValue(position.currentPrice, { currency: true });
                            const marketValueLabel = renderValue(position.marketValue, { currency: true });
                            const avgPriceLabel = renderValue(avgPrice, { currency: true });
                            const strikeDecimals = Number.isFinite(Number(position.strike)) && Number(position.strike) % 1 === 0 ? 0 : 2;
                            const strikeLabel = renderValue(position.strike, { currency: true, decimals: strikeDecimals });
                            const expiryLabel = position.expiry ? escapeHtml(position.expiry) : 'N/A';
                            const callPutLabel = formatCallPut(position.callPut, position.symbol);

                            return `
                                <article class="border border-slate-200 rounded-xl p-4 shadow-sm bg-white">
                                    <div class="flex items-start justify-between gap-2">
                                        <div>
                                            <div class="text-sm font-semibold text-slate-800">${symbol}</div>
                                            <div class="text-xs text-slate-500">${description}</div>
                                        </div>
                                        <div class="flex flex-col items-end gap-1">
                                            <span class="inline-flex items-center px-2 py-0.5 rounded-full bg-slate-100 text-[11px] font-semibold text-slate-600 uppercase tracking-wide">${escapeHtml(callPutLabel)}</span>
                                            <span class="text-[11px] text-slate-400">Exp ${expiryLabel}</span>
                                        </div>
                                    </div>
                                    <div class="mt-3 grid grid-cols-2 gap-3 text-xs text-slate-500">
                                        <div>
                                            <div class="text-[10px] uppercase tracking-wide text-slate-400">Contracts</div>
                                            <div class="text-sm font-semibold text-slate-700">${quantity != null ? escapeHtml(String(quantity)) : 'N/A'}</div>
                                        </div>
                                        <div>
                                            <div class="text-[10px] uppercase tracking-wide text-slate-400">Avg Price</div>
                                            <div class="text-sm font-semibold text-slate-700">${escapeHtml(avgPriceLabel)}</div>
                                        </div>
                                        <div>
                                            <div class="text-[10px] uppercase tracking-wide text-slate-400">Last</div>
                                            <div class="text-sm font-semibold text-slate-700">${escapeHtml(currentPriceLabel)}</div>
                                        </div>
                                        <div>
                                            <div class="text-[10px] uppercase tracking-wide text-slate-400">Market Value</div>
                                            <div class="text-sm font-semibold text-slate-700">${escapeHtml(marketValueLabel)}</div>
                                        </div>
                                        <div>
                                            <div class="text-[10px] uppercase tracking-wide text-slate-400">Strike</div>
                                            <div class="text-sm font-semibold text-slate-700">${escapeHtml(strikeLabel)}</div>
                                        </div>
                                        <div>
                                            <div class="text-[10px] uppercase tracking-wide text-slate-400">P&L</div>
                                            <div class="text-sm font-semibold ${pnlClass}">${escapeHtml(pnlLabel)} <span class="text-[11px] text-slate-400">(${escapeHtml(pnlPercentLabel)})</span></div>
                                        </div>
                                    </div>
                                    <div class="mt-3 flex items-center justify-between gap-2">
                                        <button class="inline-flex items-center gap-2 text-xs font-semibold px-3 py-2 rounded-lg bg-rose-600 text-white hover:bg-rose-700" data-action="emergency-sell" data-option-symbol="${symbol}" data-symbol="${symbol}" data-quantity="${quantity != null ? quantity : 0}" data-position-id="${escapeHtml(position.positionId || '')}" data-call-put="${escapeHtml(position.callPut || '')}" data-strike="${Number.isFinite(position.strike) ? position.strike : ''}" data-expiry="${escapeHtml(position.expiry || '')}">
                                            <i data-lucide="log-out" class="w-3 h-3"></i>
                                            Exit
                                        </button>
                                        <span class="text-[11px] text-slate-400">${escapeHtml(accountDetails?.accountDesc || 'Brokerage')}</span>
                                    </div>
                                </article>
                            `;
                        })
                        .join('');

                    portfolioOptionsList.innerHTML = optionCards;
                    if (portfolioEmptyState) {
                        portfolioEmptyState.classList.add('hidden');
                    }
                } else {
                    portfolioOptionsList.innerHTML = '';
                    if (portfolioEmptyState) {
                        const accountLabel = accountDetails?.accountDesc ? `${escapeHtml(accountDetails.accountDesc)}` : 'this account';
                        portfolioEmptyState.innerHTML = `
                            <i data-lucide="archive" class="w-6 h-6 text-slate-300 mx-auto mb-2"></i>
                            <div>No options positions in ${accountLabel}.</div>
                            <div class="text-xs text-slate-400">Refresh or run a new scan to check for updates.</div>
                        `;
                        portfolioEmptyState.classList.remove('hidden');
                    }
                }
            }

            lucide.createIcons();
        }

        // Display basic account info when portfolio fails to load
        function displayBasicAccountInfo(accountDetails) {
            if (!accountDetails) {
                return;
            }

            revealPortfolioRail();
            lastPortfolioPayload = null;
            lastPortfolioBalance = null;

            const safe = (value, fallback = '') => escapeHtml(value != null ? value : fallback);
            const accountIdDisplay = escapeHtml(getAccountIdString(accountDetails?.accountId || accountDetails?.accountIdKey || 'N/A'));

            if (accountSummary) {
                accountSummary.innerHTML = `
                    <div class="bg-slate-50 border border-slate-100 rounded-lg p-3">
                        <div class="text-[11px] uppercase tracking-wide text-slate-400">Account ID</div>
                        <div class="text-base font-semibold text-blue-600">${accountIdDisplay}</div>
                    </div>
                    <div class="bg-slate-50 border border-slate-100 rounded-lg p-3">
                        <div class="text-[11px] uppercase tracking-wide text-slate-400">Account Type</div>
                        <div class="text-base font-semibold text-emerald-600">${safe(accountDetails.accountType, 'INDIVIDUAL')}</div>
                    </div>
                    <div class="bg-slate-50 border border-slate-100 rounded-lg p-3">
                        <div class="text-[11px] uppercase tracking-wide text-slate-400">Mode</div>
                        <div class="text-base font-semibold text-purple-600">${safe(accountDetails.accountMode, 'CASH')}</div>
                    </div>
                    <div class="bg-slate-50 border border-slate-100 rounded-lg p-3">
                        <div class="text-[11px] uppercase tracking-wide text-slate-400">Status</div>
                        <div class="text-base font-semibold text-amber-600">${safe(accountDetails.accountStatus, 'ACTIVE')}</div>
                    </div>
                `;
            }

            if (portfolioOptionsList) {
                portfolioOptionsList.innerHTML = `
                    <div class="border border-slate-200 bg-slate-50 rounded-lg p-4 text-sm text-slate-600">
                        <div class="flex items-start gap-2">
                            <i data-lucide="info" class="w-4 h-4 text-blue-500 mt-0.5"></i>
                            <div>
                                <div class="font-semibold text-slate-700">Positions unavailable for this account.</div>
                                <div class="text-xs text-slate-500 mt-1">Balances are still shown above when provided by the broker.</div>
                            </div>
                        </div>
                    </div>
                `;
            }

            if (portfolioOptionsMeta) {
                portfolioOptionsMeta.textContent = '';
            }

            if (portfolioEmptyState) {
                portfolioEmptyState.classList.add('hidden');
            }

            lucide.createIcons();
        }

        async function loadScanConfig() {
            try {
                setSymbolsStatus('loading', 'Loading scan settings...');
                setStrategyStatus('loading', 'Loading strategy preference...');
                if (strategySelect) {
                    strategySelect.disabled = true;
                }
                const response = await fetch('/api/scan/config');
                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}`);
                }
                const data = await response.json();
                if (!data.success) {
                    throw new Error(data.error || 'Failed to load configuration.');
                }
                applyScanConfig(data.config, { updateInput: true, updateStatus: true });
                if (symbolsInput) {
                    symbolsInput.value = currentSymbolList.join(', ');
                }
                if (strategySelect) {
                    strategySelect.disabled = false;
                }
            } catch (error) {
                console.error('Failed to load scan config:', error);
                setSymbolsStatus('error', 'Unable to load symbol list');
                setStrategyStatus('error', 'Unable to load strategy preference');
                if (strategySelect) {
                    strategySelect.disabled = false;
                }
            }
        }

        async function saveScanSettings() {
            if (!saveSymbolsBtn) return;
            const normalized = normalizeSymbolInput(symbolsInput ? symbolsInput.value : currentSymbolList);
            if (normalized.length === 0) {
                setSymbolsStatus('warning', 'Enter at least one valid ticker symbol.');
                return;
            }
            if (normalized.length > 24) {
                setSymbolsStatus('warning', 'Please limit the list to 24 symbols.');
                return;
            }

            const selectedStrategyRaw = strategySelect ? strategySelect.value : currentStrategy;
            const selectedStrategy = typeof selectedStrategyRaw === 'string' ? selectedStrategyRaw.trim().toLowerCase() : currentStrategy;
            const strategyValid = Object.prototype.hasOwnProperty.call(STRATEGY_METADATA, selectedStrategy);
            if (!strategyValid) {
                setStrategyStatus('error', 'Choose a valid strategy (day_trade or swing_trade).');
                return;
            }

            const noSymbolChanges = arraysShallowEqual(normalized, currentSymbolList);
            const noStrategyChange = selectedStrategy === currentStrategy;
            if (noSymbolChanges && noStrategyChange) {
                setSymbolsStatus('info', 'No scan setting changes detected.');
                const label = formatStrategyLabel(currentStrategy);
                setStrategyStatus('info', `${label} • ${formatStrategyDescription(currentStrategy)}`);
                return;
            }

            saveSymbolsBtn.disabled = true;
            if (strategySelect) {
                strategySelect.disabled = true;
            }
            saveSymbolsBtn.innerHTML = '<i data-lucide="loader" class="w-4 h-4 animate-spin"></i> Saving...';
            lucide.createIcons();
            setSymbolsStatus('loading', 'Saving scan settings...');
            setStrategyStatus('loading', 'Applying strategy preference...');

            try {
                const response = await fetch('/api/scan/config', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ symbols: normalized, strategy: selectedStrategy })
                });
                const data = await response.json();
                if (!response.ok || !data.success) {
                    throw new Error(data.error || 'Failed to update scan settings.');
                }
                if (symbolsInput) {
                    symbolsInput.value = normalized.join(', ');
                }
                applyScanConfig(data.config, { updateInput: false, updateStatus: false });
                currentSymbolList = Array.from(normalized);
                currentStrategy = selectedStrategy;
                setSymbolsStatus('success', `Scan settings updated (${formatSymbolSummary(normalized)})`);
                const label = formatStrategyLabel(selectedStrategy);
                const description = formatStrategyDescription(selectedStrategy);
                setStrategyStatus('success', `${label} • ${description}`);
                await fetchRecommendations();
            } catch (error) {
                console.error('Scan settings save failed:', error);
                const message = error?.message || 'Failed to update scan settings.';
                setSymbolsStatus('error', message);
                setStrategyStatus('error', message);
            } finally {
                saveSymbolsBtn.disabled = false;
                if (strategySelect) {
                    strategySelect.disabled = false;
                }
                saveSymbolsBtn.innerHTML = '<i data-lucide="save" class="w-4 h-4"></i> Save Scan Settings';
                lucide.createIcons();
            }
        }

        // Load initial data
        async function loadInitialData() {
            // Initialize header balance display
            updateHeaderBalance(null);
            updateScanStatus(null);
            await loadScanConfig();
            await fetchRecommendations();
            startRecommendationsPolling();
            initializePortfolioRail();
        }

        loadInitialData();
    </script>
</body>
</html>